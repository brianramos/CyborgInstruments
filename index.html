<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0">
    <title>üåà Rainbow Unicorn Bunny Fluffcore üê∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .app-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .drumkit-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: linear-gradient(135deg, rgba(255,107,107,0.95), rgba(255,182,193,0.95), rgba(168,237,234,0.95));
            padding: 5px 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border-bottom: 3px solid rgba(255,255,255,0.5);
            flex-wrap: wrap;
        }

        .drum-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .drum-btn:active, .drum-btn.playing {
            transform: scale(0.85);
        }

        .ctrl-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            font-size: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .record-btn { background: linear-gradient(135deg, #ff4757, #c0392b); color: white; }
        .record-btn.recording { animation: recordPulse 0.5s ease-in-out infinite; box-shadow: 0 0 15px #ff4757; }
        .stop-btn { background: linear-gradient(135deg, #2f3542, #57606f); color: white; }
        .export-btn { background: linear-gradient(135deg, #2ed573, #1e90ff); color: white; }
        .autobeat-btn { background: linear-gradient(135deg, #ffa502, #ff6348); color: white; font-size: 0.6rem; }
        .autotune-btn-top { background: linear-gradient(135deg, #a55eea, #8854d0); color: white; font-size: 0.6rem; }
        .autobeat-btn.active, .autotune-btn-top.active { box-shadow: 0 0 12px currentColor; transform: scale(1.1); }

        @keyframes recordPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .drum-0 { background: linear-gradient(135deg, #ff6b6b, #ee5a5a); }
        .drum-1 { background: linear-gradient(135deg, #feca57, #f9b234); }
        .drum-2 { background: linear-gradient(135deg, #48dbfb, #2ec4ea); }
        .drum-3 { background: linear-gradient(135deg, #ff9ff3, #f368e0); }
        .drum-4 { background: linear-gradient(135deg, #a55eea, #8854d0); }
        .drum-5 { background: linear-gradient(135deg, #1dd1a1, #10ac84); }
        .drum-6 { background: linear-gradient(135deg, #5f27cd, #4a1fb8); }
        .drum-7 { background: linear-gradient(135deg, #ff9f43, #ee8620); }
        .drum-8 { background: linear-gradient(135deg, #00d2d3, #00b5b6); }
        .drum-9 { background: linear-gradient(135deg, #fd79a8, #e84393); }

        .scene-container {
            display: flex;
            width: 400%;
            height: 100%;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            padding-top: 44px;
        }

        .scene {
            width: 25%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .scene-1 { background: linear-gradient(180deg, #ff9a9e 0%, #fecfef 50%, #a8edea 100%); }
        .scene-2 { background: linear-gradient(180deg, #667eea 0%, #764ba2 50%, #f093fb 100%); }
        .scene-3 { background: linear-gradient(180deg, #a1c4fd 0%, #c2e9fb 50%, #fff1eb 100%); }
        .scene-4 { background: linear-gradient(180deg, #434343 0%, #1a1a2e 50%, #16213e 100%); }

        .header {
            padding: 3px 8px;
            text-align: center;
        }

        .scene-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .scene-subtitle {
            font-size: 0.55rem;
            color: rgba(255,255,255,0.9);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 3px;
            padding: 2px 5px;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 3px 5px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-size: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.6;
        }

        .mode-btn.active {
            opacity: 1;
            border-color: white;
        }

        .beat-btn { background: linear-gradient(135deg, #ff6b6b, #feca57); color: white; }
        .melody-btn { background: linear-gradient(135deg, #5f27cd, #48dbfb); color: white; }

        .touch-pad {
            flex: 1;
            margin: 3px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 40px rgba(0,0,0,0.1), 0 8px 25px rgba(0,0,0,0.2);
        }

        .scene-1 .touch-pad { background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,182,193,0.3)); border: 2px solid rgba(255,255,255,0.5); }
        .scene-2 .touch-pad { background: linear-gradient(135deg, rgba(138,43,226,0.3), rgba(75,0,130,0.3)); border: 2px solid rgba(200,150,255,0.5); }
        .scene-3 .touch-pad { background: linear-gradient(135deg, rgba(255,255,255,0.4), rgba(200,230,255,0.3)); border: 2px solid rgba(255,255,255,0.6); }

        .touch-indicator {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .touch-ring {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            border: 3px solid rgba(255,255,255,0.5);
            animation: ringPulse 1s ease-out infinite;
        }

        @keyframes ringPulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        .layer-display {
            display: flex;
            justify-content: center;
            gap: 3px;
            padding: 3px;
        }

        .layer-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            opacity: 0.3;
            transform: scale(0.7);
        }

        .layer-indicator.active {
            opacity: 1;
            transform: scale(1);
        }

        .scene-dots {
            position: fixed;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: rgba(255,255,255,0.5);
            cursor: pointer;
        }

        .dot.active {
            background: white;
            transform: scale(1.3);
        }

        .floating-element {
            position: absolute;
            pointer-events: none;
            animation: float 3s ease-in-out infinite;
            opacity: 0.5;
            font-size: 1rem;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        .sparkle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: white;
            border-radius: 50%;
            animation: sparkle 0.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes sparkle {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .xy-label {
            position: absolute;
            color: white;
            font-size: 0.45rem;
            opacity: 0.5;
            pointer-events: none;
        }

        .xy-label.pitch { top: 2px; left: 50%; transform: translateX(-50%); }
        .xy-label.pitch-low { bottom: 2px; left: 50%; transform: translateX(-50%); }
        .xy-label.tone { left: 2px; top: 50%; transform: translateY(-50%) rotate(-90deg); }
        .xy-label.tone-bright { right: 2px; top: 50%; transform: translateY(-50%) rotate(90deg); }

        .active-modes-display {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 4px;
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
            pointer-events: none;
        }

        .active-mode-tag {
            padding: 1px 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            font-size: 0.45rem;
            color: white;
        }

        .record-indicator {
            position: fixed;
            top: 48px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,0,0,0.9);
            color: white;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.6rem;
            font-weight: bold;
            display: none;
            z-index: 300;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .record-indicator.visible { display: block; }

        /* Mixer styles */
        .mixer-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 6px;
            padding-bottom: 140px;
            gap: 6px;
            overflow-y: auto;
        }

        .mixer-header {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mixer-btn {
            padding: 5px 8px;
            border: none;
            border-radius: 6px;
            font-size: 0.55rem;
            font-weight: bold;
            cursor: pointer;
            color: white;
        }

        .import-btn { background: linear-gradient(135deg, #6c5ce7, #a29bfe); }
        .play-all-btn { background: linear-gradient(135deg, #00b894, #55efc4); }
        .stop-all-btn { background: linear-gradient(135deg, #d63031, #ff7675); }
        .clear-btn { background: linear-gradient(135deg, #636e72, #b2bec3); }

        .tracks-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-y: auto;
        }

        .track-item {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: grab;
            transition: all 0.2s;
        }

        .track-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .track-item.drag-over {
            border-color: #a29bfe;
            box-shadow: 0 0 10px rgba(162, 155, 254, 0.5);
        }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .track-name {
            color: white;
            font-size: 0.6rem;
            font-weight: bold;
        }

        .track-info {
            color: rgba(255,255,255,0.6);
            font-size: 0.5rem;
        }

        .track-controls {
            display: flex;
            gap: 3px;
        }

        .track-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 50%;
            font-size: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .track-play { background: #00b894; color: white; }
        .track-delete { background: #d63031; color: white; }
        .track-add-master { background: #6c5ce7; color: white; }

        .channel-grid {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-bottom: 4px;
        }

        .channel-row {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .channel-label {
            width: 20px;
            font-size: 0.45rem;
            color: rgba(255,255,255,0.7);
        }

        .step-grid {
            display: flex;
            gap: 1px;
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            overflow: hidden;
            flex: 1;
        }

        .step-cell {
            flex: 1;
            background: rgba(255,255,255,0.1);
            position: relative;
        }

        .step-cell.has-event {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
        }

        .step-cell.has-sustain {
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
        }

        .step-cell.beat-marker {
            border-left: 1px solid rgba(255,255,255,0.3);
        }

        .trim-controls {
            display: flex;
            gap: 4px;
            align-items: center;
            flex-wrap: wrap;
        }

        .stretch-control {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .stretch-label {
            color: rgba(255,255,255,0.7);
            font-size: 0.5rem;
        }

        .stretch-slider {
            width: 50px;
            height: 3px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .stretch-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #a29bfe;
            border-radius: 50%;
        }

        .autotune-btn, .autorhythm-btn {
            padding: 3px 6px;
            border: none;
            border-radius: 5px;
            font-size: 0.5rem;
            cursor: pointer;
            color: white;
        }

        .autotune-btn { background: linear-gradient(135deg, #fd79a8, #e84393); }
        .autorhythm-btn { background: linear-gradient(135deg, #0984e3, #74b9ff); }
        .autotune-btn.active, .autorhythm-btn.active { box-shadow: 0 0 8px currentColor; }

        .curve-select {
            padding: 2px 4px;
            border: none;
            border-radius: 3px;
            font-size: 0.5rem;
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.5);
            text-align: center;
        }

        .empty-state-icon { font-size: 2.5rem; margin-bottom: 8px; }

        .swipe-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.4);
            font-size: 0.5rem;
        }

        /* Master Channel Panel */
        .master-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(30,30,50,0.98), rgba(20,20,40,0.98));
            border-top: 2px solid rgba(162,155,254,0.5);
            padding: 8px;
            z-index: 150;
            display: none;
        }

        .master-panel.visible {
            display: block;
        }

        .master-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .master-title {
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .master-buttons {
            display: flex;
            gap: 4px;
        }

        .master-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 5px;
            font-size: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            color: white;
        }

        .master-play-btn { background: linear-gradient(135deg, #00b894, #55efc4); }
        .master-download-btn { background: linear-gradient(135deg, #f39c12, #e74c3c); }
        .master-clear-btn { background: linear-gradient(135deg, #636e72, #b2bec3); }

        .master-timeline {
            background: rgba(0,0,0,0.4);
            border-radius: 6px;
            padding: 6px;
            min-height: 60px;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .master-timeline-inner {
            display: flex;
            gap: 4px;
            min-height: 48px;
            align-items: center;
            padding: 4px;
        }

        .master-clip {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            border-radius: 4px;
            padding: 4px 8px;
            min-width: 60px;
            position: relative;
            cursor: grab;
            display: flex;
            flex-direction: column;
            gap: 2px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .master-clip:active {
            cursor: grabbing;
        }

        .master-clip.selected {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .master-clip.dragging {
            opacity: 0.6;
            transform: scale(0.95);
        }

        .master-clip-name {
            color: white;
            font-size: 0.5rem;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .master-clip-duration {
            color: rgba(255,255,255,0.7);
            font-size: 0.4rem;
        }

        .master-clip-remove {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 14px;
            height: 14px;
            background: #d63031;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .crop-handles {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            display: flex;
            justify-content: space-between;
        }

        .crop-handle {
            width: 8px;
            height: 100%;
            background: rgba(255,255,255,0.6);
            cursor: ew-resize;
            border-radius: 2px;
        }

        .crop-handle:hover {
            background: white;
        }

        .master-empty {
            color: rgba(255,255,255,0.4);
            font-size: 0.6rem;
            text-align: center;
            padding: 15px;
        }

        .drop-zone-indicator {
            position: absolute;
            width: 3px;
            height: 40px;
            background: #fff;
            border-radius: 2px;
            pointer-events: none;
            display: none;
        }

        .license-info {
            color: rgba(255,255,255,0.5);
            font-size: 0.4rem;
            text-align: center;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="drumkit-container">
            <button class="drum-btn drum-0" data-drum="0">üê±</button>
            <button class="drum-btn drum-1" data-drum="1">ü¶ä</button>
            <button class="drum-btn drum-2" data-drum="2">üê∏</button>
            <button class="drum-btn drum-3" data-drum="3">ü¶ã</button>
            <button class="drum-btn drum-4" data-drum="4">üçÑ</button>
            <button class="drum-btn drum-5" data-drum="5">üå∏</button>
            <button class="drum-btn drum-6" data-drum="6">üîÆ</button>
            <button class="drum-btn drum-7" data-drum="7">üßÅ</button>
            <button class="drum-btn drum-8" data-drum="8">ü´ß</button>
            <button class="drum-btn drum-9" data-drum="9">‚ú®</button>
            <button class="ctrl-btn record-btn" id="recordBtn" title="Record">‚è∫</button>
            <button class="ctrl-btn stop-btn" id="stopBtn" title="Stop">‚èπ</button>
            <button class="ctrl-btn export-btn" id="exportBtn" title="Export">üíæ</button>
            <button class="ctrl-btn autobeat-btn" id="autoBeatBtn" title="Auto-Lock Beat">üéØ</button>
            <button class="ctrl-btn autotune-btn-top" id="autoTuneBtn" title="Auto-Tune">üéµ</button>
        </div>

        <div class="record-indicator" id="recordIndicator">‚óè REC</div>

        <div class="scene-container" id="sceneContainer">
            <!-- Scene 1: Rainbow Meadow -->
            <div class="scene scene-1" data-scene="0">
                <div class="floating-element" style="top: 1%; left: 8%;">ü¶Ñ</div>
                <div class="floating-element" style="top: 3%; right: 12%; animation-delay: 0.5s;">üê∞</div>
                
                <div class="header">
                    <div class="scene-title">üåà Rainbow Meadow üå∏</div>
                    <div class="scene-subtitle">X: Tone | Y: Pitch</div>
                </div>
                
                <div class="controls">
                    <button class="mode-btn beat-btn" data-beat="0">Hop</button>
                    <button class="mode-btn beat-btn" data-beat="1">Skip</button>
                    <button class="mode-btn beat-btn" data-beat="2">Bounce</button>
                    <button class="mode-btn beat-btn" data-beat="3">Flutter</button>
                    <button class="mode-btn beat-btn" data-beat="4">Gallop</button>
                </div>
                <div class="controls">
                    <button class="mode-btn melody-btn" data-melody="0">Sparkle</button>
                    <button class="mode-btn melody-btn" data-melody="1">Dream</button>
                    <button class="mode-btn melody-btn" data-melody="2">Magic</button>
                    <button class="mode-btn melody-btn" data-melody="3">Wish</button>
                    <button class="mode-btn melody-btn" data-melody="4">Glow</button>
                </div>
                
                <div class="touch-pad" data-scene-index="0">
                    <div class="xy-label pitch">‚Üë HIGH</div>
                    <div class="xy-label pitch-low">‚Üì LOW</div>
                    <div class="xy-label tone">WARM</div>
                    <div class="xy-label tone-bright">BRIGHT</div>
                    <div class="active-modes-display"></div>
                </div>
                
                <div class="layer-display">
                    <div class="layer-indicator" style="background: #ff6b6b;">üéµ</div>
                    <div class="layer-indicator" style="background: #feca57;">üé∂</div>
                    <div class="layer-indicator" style="background: #48dbfb;">‚ú®</div>
                    <div class="layer-indicator" style="background: #ff9ff3;">üí´</div>
                    <div class="layer-indicator" style="background: #a55eea;">üåü</div>
                </div>
            </div>

            <!-- Scene 2: Crystal Cave -->
            <div class="scene scene-2" data-scene="1">
                <div class="floating-element" style="top: 1%; left: 10%;">üíé</div>
                <div class="floating-element" style="top: 3%; right: 15%; animation-delay: 0.7s;">üîÆ</div>
                
                <div class="header">
                    <div class="scene-title">üíé Crystal Cave üîÆ</div>
                    <div class="scene-subtitle">X: Resonance | Y: Frequency</div>
                </div>
                
                <div class="controls">
                    <button class="mode-btn beat-btn" data-beat="0">Echo</button>
                    <button class="mode-btn beat-btn" data-beat="1">Pulse</button>
                    <button class="mode-btn beat-btn" data-beat="2">Crystal</button>
                    <button class="mode-btn beat-btn" data-beat="3">Cave</button>
                    <button class="mode-btn beat-btn" data-beat="4">Deep</button>
                </div>
                <div class="controls">
                    <button class="mode-btn melody-btn" data-melody="0">Mystic</button>
                    <button class="mode-btn melody-btn" data-melody="1">Aura</button>
                    <button class="mode-btn melody-btn" data-melody="2">Spirit</button>
                    <button class="mode-btn melody-btn" data-melody="3">Ethereal</button>
                    <button class="mode-btn melody-btn" data-melody="4">Cosmic</button>
                </div>
                
                <div class="touch-pad" data-scene-index="1">
                    <div class="xy-label pitch">‚Üë HIGH</div>
                    <div class="xy-label pitch-low">‚Üì LOW</div>
                    <div class="xy-label tone">DEEP</div>
                    <div class="xy-label tone-bright">CRYSTAL</div>
                    <div class="active-modes-display"></div>
                </div>
                
                <div class="layer-display">
                    <div class="layer-indicator" style="background: #a55eea;">üéπ</div>
                    <div class="layer-indicator" style="background: #5f27cd;">üé∏</div>
                    <div class="layer-indicator" style="background: #341f97;">üé∫</div>
                    <div class="layer-indicator" style="background: #48dbfb;">üéª</div>
                    <div class="layer-indicator" style="background: #0abde3;">ü™à</div>
                </div>
            </div>

            <!-- Scene 3: Cloud Kingdom -->
            <div class="scene scene-3" data-scene="2">
                <div class="floating-element" style="top: 1%; left: 8%;">‚òÅÔ∏è</div>
                <div class="floating-element" style="top: 3%; right: 12%; animation-delay: 0.3s;">‚≠ê</div>
                
                <div class="header">
                    <div class="scene-title">‚òÅÔ∏è Cloud Kingdom üåô</div>
                    <div class="scene-subtitle">X: Softness | Y: Dreaminess</div>
                </div>
                
                <div class="controls">
                    <button class="mode-btn beat-btn" data-beat="0">Float</button>
                    <button class="mode-btn beat-btn" data-beat="1">Drift</button>
                    <button class="mode-btn beat-btn" data-beat="2">Breeze</button>
                    <button class="mode-btn beat-btn" data-beat="3">Whisper</button>
                    <button class="mode-btn beat-btn" data-beat="4">Lullaby</button>
                </div>
                <div class="controls">
                    <button class="mode-btn melody-btn" data-melody="0">Sleepy</button>
                    <button class="mode-btn melody-btn" data-melody="1">Dreamy</button>
                    <button class="mode-btn melody-btn" data-melody="2">Fluffy</button>
                    <button class="mode-btn melody-btn" data-melody="3">Soft</button>
                    <button class="mode-btn melody-btn" data-melody="4">Gentle</button>
                </div>
                
                <div class="touch-pad" data-scene-index="2">
                    <div class="xy-label pitch">‚Üë AIRY</div>
                    <div class="xy-label pitch-low">‚Üì COZY</div>
                    <div class="xy-label tone">SOFT</div>
                    <div class="xy-label tone-bright">SHIMMER</div>
                    <div class="active-modes-display"></div>
                </div>
                
                <div class="layer-display">
                    <div class="layer-indicator" style="background: #74b9ff;">üå∏</div>
                    <div class="layer-indicator" style="background: #a29bfe;">ü¶ã</div>
                    <div class="layer-indicator" style="background: #fd79a8;">üå∫</div>
                    <div class="layer-indicator" style="background: #fdcb6e;">üåª</div>
                    <div class="layer-indicator" style="background: #81ecec;">üçÄ</div>
                </div>
            </div>

            <!-- Scene 4: Mixer Studio -->
            <div class="scene scene-4" data-scene="3">
                <div class="header">
                    <div class="scene-title">üéõÔ∏è Mixer Studio üéöÔ∏è</div>
                    <div class="scene-subtitle">Import, Mix & Master</div>
                </div>
                
                <div class="mixer-container">
                    <div class="mixer-header">
                        <button class="mixer-btn import-btn" id="importBtn">üì• Import</button>
                        <button class="mixer-btn play-all-btn" id="playAllBtn">‚ñ∂Ô∏è Play</button>
                        <button class="mixer-btn stop-all-btn" id="stopAllBtn">‚èπ Stop</button>
                        <button class="mixer-btn clear-btn" id="clearAllBtn">üóëÔ∏è Clear</button>
                    </div>
                    
                    <div class="tracks-container" id="tracksContainer">
                        <div class="empty-state" id="emptyState">
                            <div class="empty-state-icon">üéµ</div>
                            <div style="font-size: 0.7rem;">No tracks yet!</div>
                            <div style="font-size: 0.55rem; margin-top: 4px;">Record or import JSON</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Master Channel Panel -->
        <div class="master-panel" id="masterPanel">
            <div class="master-header">
                <div class="master-title">üéπ Master Channel ‚ú®</div>
                <div class="master-buttons">
                    <button class="master-btn master-play-btn" id="masterPlayBtn">‚ñ∂Ô∏è Play</button>
                    <button class="master-btn master-download-btn" id="masterDownloadBtn">üíæ CC0</button>
                    <button class="master-btn master-clear-btn" id="masterClearBtn">üóëÔ∏è</button>
                </div>
            </div>
            <div class="master-timeline" id="masterTimeline">
                <div class="master-timeline-inner" id="masterTimelineInner">
                    <div class="master-empty" id="masterEmpty">
                        Drag tracks here or tap ‚ûï to add clips üéµ
                    </div>
                </div>
                <div class="drop-zone-indicator" id="dropIndicator"></div>
            </div>
            <div class="license-info">üìú CC0 1.0 Universal - Public Domain Dedication</div>
        </div>

        <div class="scene-dots">
            <div class="dot active" data-scene="0"></div>
            <div class="dot" data-scene="1"></div>
            <div class="dot" data-scene="2"></div>
            <div class="dot" data-scene="3"></div>
        </div>
        
        <div class="swipe-hint">‚Üê Swipe to change scenes ‚Üí</div>
    </div>

    <input type="file" id="fileInput" accept=".json" multiple style="display:none;">

    <script>
        // Configuration
        const BPM = 120;
        const STEP_DURATION = (60000 / BPM) / 4;
        const STEPS_PER_BAR = 16;
        const TOTAL_STEPS = 64;
        const MAX_HARMONY_CHANNELS = 5;
        
        // Audio Context
        let audioContext;
        let masterGain;
        
        // Recording state
        let isRecording = false;
        let recordingStartTime = 0;
        let autoBeatLock = false;
        let autoTuneLock = false;
        let currentRecording = null;
        
        // Active sustained notes for playback
        let activeSustainedNotes = new Map();
        
        // Playback state
        let isPlaying = false;
        let playbackTimeouts = [];
        
        // Mixer tracks
        let mixerTracks = [];
        
        // Master channel clips
        let masterClips = [];
        let selectedClipIndex = -1;
        
        // Scene management
        let currentScene = 0;
        
        // Drag state
        let draggedTrackIndex = null;
        let draggedClipIndex = null;
        let cropDragData = null;
        
        // Stackable mode settings per scene
        const sceneSettings = [
            { beatModes: new Set(), melodyModes: new Set() },
            { beatModes: new Set(), melodyModes: new Set() },
            { beatModes: new Set(), melodyModes: new Set() }
        ];
        
        // Beat loop management
        const beatLoops = [
            { intervals: [], active: false },
            { intervals: [], active: false },
            { intervals: [], active: false }
        ];
        
        // Drum sounds config
        const drumSounds = [
            { emoji: 'üê±', freq: 180, type: 'sine', decay: 0.3, pitch: 1.5 },
            { emoji: 'ü¶ä', freq: 120, type: 'triangle', decay: 0.25, pitch: 0.8 },
            { emoji: 'üê∏', freq: 80, type: 'square', decay: 0.15, pitch: 2 },
            { emoji: 'ü¶ã', freq: 800, type: 'sine', decay: 0.5, pitch: 1.2 },
            { emoji: 'üçÑ', freq: 60, type: 'sawtooth', decay: 0.4, pitch: 0.5 },
            { emoji: 'üå∏', freq: 600, type: 'sine', decay: 0.6, pitch: 1.8 },
            { emoji: 'üîÆ', freq: 400, type: 'triangle', decay: 0.7, pitch: 0.7 },
            { emoji: 'üßÅ', freq: 300, type: 'sine', decay: 0.2, pitch: 1.3 },
            { emoji: 'ü´ß', freq: 1200, type: 'sine', decay: 0.4, pitch: 2.5 },
            { emoji: '‚ú®', freq: 2000, type: 'sine', decay: 0.3, pitch: 3 }
        ];
        
        // Scales for melodies
        const melodyScales = [
            [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25],
            [293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33],
            [329.63, 369.99, 415.30, 466.16, 523.25, 587.33, 659.25, 739.99],
            [349.23, 392.00, 440.00, 466.16, 523.25, 587.33, 622.25, 698.46],
            [392.00, 440.00, 493.88, 523.25, 587.33, 659.25, 698.46, 783.99]
        ];
        
        const beatPatterns = [
            { intervals: [250, 250, 250, 250], accents: [1, 0.5, 0.7, 0.5] },
            { intervals: [200, 400, 200, 400], accents: [1, 0.3, 0.8, 0.4] },
            { intervals: [150, 150, 300, 150, 150], accents: [1, 0.6, 0.4, 0.8, 0.5] },
            { intervals: [300, 150, 150, 300], accents: [0.8, 0.5, 0.5, 1] },
            { intervals: [400, 200, 200, 400, 200], accents: [1, 0.4, 0.6, 0.8, 0.3] }
        ];
        
        const layerColors = [
            ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#a55eea'],
            ['#a55eea', '#5f27cd', '#341f97', '#48dbfb', '#0abde3'],
            ['#74b9ff', '#a29bfe', '#fd79a8', '#fdcb6e', '#81ecec']
        ];
        
        const synthConfigs = [
            { types: ['sine', 'triangle', 'sine', 'triangle', 'sine'], filterBase: 2000 },
            { types: ['sawtooth', 'square', 'triangle', 'sine', 'sawtooth'], filterBase: 1500 },
            { types: ['sine', 'sine', 'triangle', 'sine', 'triangle'], filterBase: 3000 }
        ];

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.25;
                masterGain.connect(audioContext.destination);
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function getRecordingTime() {
            return Date.now() - recordingStartTime;
        }

        function timeToStep(time) {
            return time / STEP_DURATION;
        }

        function stepToTime(step) {
            return step * STEP_DURATION;
        }

        function quantizeToScale(freq, scaleIndex = 0) {
            const scale = melodyScales[scaleIndex];
            let closest = scale[0];
            let minDiff = Math.abs(freq - closest);
            
            for (const note of scale) {
                const diff = Math.abs(freq - note);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = note;
                }
            }
            return closest;
        }

        function createNewRecording() {
            return {
                version: "3.0",
                name: `Recording ${new Date().toLocaleTimeString()}`,
                bpm: BPM,
                stepsPerBar: STEPS_PER_BAR,
                totalSteps: TOTAL_STEPS,
                duration: 0,
                autoBeat: autoBeatLock,
                autoTune: autoTuneLock,
                channels: {
                    beats: { type: "beats", events: [] },
                    harmony: []
                }
            };
        }

        function recordDrumHit(drumIndex) {
            if (!isRecording || !currentRecording) return;
            
            let time = getRecordingTime();
            let step = timeToStep(time);
            
            if (autoBeatLock) step = Math.round(step);
            
            if (step < TOTAL_STEPS) {
                currentRecording.channels.beats.events.push({ step, drumIndex });
            }
        }

        function getOrCreateHarmonyChannel(channelIndex, sceneIndex) {
            if (!currentRecording) return null;
            
            let channel = currentRecording.channels.harmony.find(
                c => c.channelIndex === channelIndex && c.sceneIndex === sceneIndex
            );
            
            if (!channel) {
                channel = { channelIndex, sceneIndex, notes: [] };
                currentRecording.channels.harmony.push(channel);
            }
            
            return channel;
        }

        function startPadRecording(sceneIndex, fingerIndex, x, y, normX, normY) {
            if (!isRecording || !currentRecording) return null;
            
            let time = getRecordingTime();
            let step = timeToStep(time);
            
            if (autoBeatLock) step = Math.round(step);
            
            let freq = calculateFrequency(sceneIndex, normY);
            if (autoTuneLock) freq = quantizeToScale(freq, 0);
            const filter = calculateFilter(sceneIndex, normX);
            
            const channel = getOrCreateHarmonyChannel(fingerIndex, sceneIndex);
            if (!channel) return null;
            
            const noteData = {
                startStep: step,
                endStep: null,
                events: [{ step, x: normX, y: normY, freq, filter }]
            };
            
            channel.notes.push(noteData);
            
            return { channelIndex: fingerIndex, sceneIndex, noteIndex: channel.notes.length - 1 };
        }

        function updatePadRecording(recordRef, normX, normY, sceneIndex) {
            if (!isRecording || !currentRecording || !recordRef) return;
            
            const channel = currentRecording.channels.harmony.find(
                c => c.channelIndex === recordRef.channelIndex && c.sceneIndex === recordRef.sceneIndex
            );
            if (!channel) return;
            
            const noteData = channel.notes[recordRef.noteIndex];
            if (!noteData) return;
            
            let time = getRecordingTime();
            let step = timeToStep(time);
            
            if (autoBeatLock) step = Math.round(step);
            
            const lastEvent = noteData.events[noteData.events.length - 1];
            if (step > lastEvent.step && step < TOTAL_STEPS) {
                let freq = calculateFrequency(sceneIndex, normY);
                if (autoTuneLock) freq = quantizeToScale(freq, 0);
                const filter = calculateFilter(sceneIndex, normX);
                
                noteData.events.push({ step, x: normX, y: normY, freq, filter });
            }
        }

        function endPadRecording(recordRef) {
            if (!isRecording || !currentRecording || !recordRef) return;
            
            const channel = currentRecording.channels.harmony.find(
                c => c.channelIndex === recordRef.channelIndex && c.sceneIndex === recordRef.sceneIndex
            );
            if (!channel) return;
            
            const noteData = channel.notes[recordRef.noteIndex];
            if (!noteData) return;
            
            let time = getRecordingTime();
            let step = timeToStep(time);
            
            if (autoBeatLock) step = Math.round(step);
            
            noteData.endStep = step;
        }

        function calculateFrequency(sceneIndex, normY) {
            const settings = sceneSettings[sceneIndex];
            const activeMelodies = Array.from(settings.melodyModes);
            if (activeMelodies.length === 0) return 440;
            
            const scale = melodyScales[activeMelodies[0]];
            const scaleIndex = Math.floor(normY * (scale.length - 1));
            return scale[scaleIndex];
        }

        function calculateFilter(sceneIndex, normX) {
            const config = synthConfigs[sceneIndex];
            return config.filterBase + (normX * 4000);
        }

        function startRecording() {
            isRecording = true;
            recordingStartTime = Date.now();
            currentRecording = createNewRecording();
            document.getElementById('recordBtn').classList.add('recording');
            document.getElementById('recordIndicator').classList.add('visible');
            
            setTimeout(() => {
                if (isRecording) stopRecording();
            }, TOTAL_STEPS * STEP_DURATION);
        }

        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            if (currentRecording) {
                currentRecording.duration = getRecordingTime();
                
                const hasBeats = currentRecording.channels.beats.events.length > 0;
                const hasHarmony = currentRecording.channels.harmony.some(c => c.notes.length > 0);
                
                if (hasBeats || hasHarmony) {
                    mixerTracks.push(currentRecording);
                    renderTracks();
                    updateMasterPanelVisibility();
                }
            }
            
            document.getElementById('recordBtn').classList.remove('recording');
            document.getElementById('recordIndicator').classList.remove('visible');
        }

        function stopAllPlayback() {
            playbackTimeouts.forEach(id => clearTimeout(id));
            playbackTimeouts = [];
            isPlaying = false;
            
            activeSustainedNotes.forEach(noteData => {
                if (noteData.gainNode) {
                    noteData.gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.05);
                }
                if (noteData.oscillator) {
                    setTimeout(() => { try { noteData.oscillator.stop(); } catch(e) {} }, 100);
                }
            });
            activeSustainedNotes.clear();
            
            [0, 1, 2].forEach(i => stopBeatLoops(i));
        }

        function exportRecording() {
            if (!currentRecording) {
                if (mixerTracks.length > 0) {
                    const exportData = { version: "3.0", tracks: mixerTracks };
                    const json = JSON.stringify(exportData, null, 2);
                    downloadJson(json, 'fluffcore-mix');
                } else {
                    alert('Nothing to export!');
                }
                return;
            }
            
            const hasContent = currentRecording.channels.beats.events.length > 0 ||
                currentRecording.channels.harmony.some(c => c.notes.length > 0);
            
            if (!hasContent) {
                if (mixerTracks.length > 0) {
                    const exportData = { version: "3.0", tracks: mixerTracks };
                    const json = JSON.stringify(exportData, null, 2);
                    downloadJson(json, 'fluffcore-mix');
                } else {
                    alert('Nothing to export!');
                }
                return;
            }
            
            const json = JSON.stringify(currentRecording, null, 2);
            downloadJson(json, 'fluffcore-track');
        }

        function downloadJson(json, prefix) {
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${prefix}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Auto-beat button
        document.getElementById('autoBeatBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            autoBeatLock = !autoBeatLock;
            e.target.classList.toggle('active', autoBeatLock);
        });

        // Auto-tune button
        document.getElementById('autoTuneBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            autoTuneLock = !autoTuneLock;
            e.target.classList.toggle('active', autoTuneLock);
        });

        // Record button
        document.getElementById('recordBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            initAudio();
            
            if (isRecording) stopRecording();
            else startRecording();
        });

        // Stop button
        document.getElementById('stopBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            stopRecording();
            stopAllPlayback();
        });

        // Export button
        document.getElementById('exportBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            exportRecording();
        });

        // Drum sounds
        function playDrumSound(drumIndex, shouldRecord = true) {
            if (!audioContext) return;
            
            const drum = drumSounds[drumIndex];
            const now = audioContext.currentTime;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            osc.type = drum.type;
            osc.frequency.setValueAtTime(drum.freq * drum.pitch, now);
            osc.frequency.exponentialRampToValueAtTime(drum.freq * 0.3, now + drum.decay);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(3000, now);
            filter.frequency.exponentialRampToValueAtTime(500, now + drum.decay);
            
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + drum.decay);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            
            osc.start(now);
            osc.stop(now + drum.decay + 0.1);
            
            if (shouldRecord) recordDrumHit(drumIndex);
        }

        document.querySelectorAll('.drum-btn').forEach(btn => {
            function triggerDrum(e) {
                e.preventDefault();
                e.stopPropagation();
                initAudio();
                
                const drumIndex = parseInt(btn.dataset.drum);
                playDrumSound(drumIndex);
                
                btn.classList.add('playing');
                setTimeout(() => btn.classList.remove('playing'), 150);
            }
            
            btn.addEventListener('touchstart', triggerDrum);
            btn.addEventListener('mousedown', triggerDrum);
        });

        function createContinuousTone(sceneIndex, layerIndex, x, y, padWidth, padHeight) {
            if (!audioContext) return null;
            
            const settings = sceneSettings[sceneIndex];
            const activeMelodies = Array.from(settings.melodyModes);
            if (activeMelodies.length === 0) return null;
            
            const config = synthConfigs[sceneIndex];
            const oscillators = [];
            const gainNodes = [];
            const filters = [];
            
            const normX = Math.max(0, Math.min(1, x / padWidth));
            const normY = Math.max(0, Math.min(1, 1 - (y / padHeight)));
            
            activeMelodies.forEach((melodyMode) => {
                const scale = melodyScales[melodyMode];
                const scaleIndex = Math.floor(normY * (scale.length - 1));
                let freq = scale[scaleIndex] * (1 + (layerIndex * 0.01));
                
                if (autoTuneLock) freq = quantizeToScale(freq, melodyMode);
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                oscillator.type = config.types[layerIndex % 5];
                oscillator.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = config.filterBase + (normX * 4000);
                filter.Q.value = 2 + (normX * 8);
                
                gainNode.gain.value = 0.15 / Math.max(1, activeMelodies.length);
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(masterGain);
                oscillator.start();
                
                oscillators.push(oscillator);
                gainNodes.push(gainNode);
                filters.push(filter);
            });
            
            return { oscillators, gainNodes, filters, sceneIndex };
        }

        function updateTonePosition(soundData, x, y, padWidth, padHeight) {
            if (!soundData) return;
            
            const settings = sceneSettings[soundData.sceneIndex];
            const activeMelodies = Array.from(settings.melodyModes);
            
            const normX = Math.max(0, Math.min(1, x / padWidth));
            const normY = Math.max(0, Math.min(1, 1 - (y / padHeight)));
            
            soundData.oscillators.forEach((osc, idx) => {
                const melodyMode = activeMelodies[idx];
                if (melodyMode === undefined) return;
                
                const scale = melodyScales[melodyMode];
                const scaleIndex = Math.floor(normY * (scale.length - 1));
                let freq = scale[scaleIndex];
                
                if (autoTuneLock) freq = quantizeToScale(freq, melodyMode);
                
                osc.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.05);
            });
            
            soundData.filters.forEach(filter => {
                const config = synthConfigs[soundData.sceneIndex];
                filter.frequency.setTargetAtTime(config.filterBase + (normX * 4000), audioContext.currentTime, 0.05);
            });
        }

        function stopTone(soundData) {
            if (!soundData) return;
            soundData.gainNodes.forEach(gain => {
                gain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
            });
            setTimeout(() => {
                soundData.oscillators.forEach(osc => { try { osc.stop(); } catch(e) {} });
            }, 300);
        }

        function createBeatSound(beatMode, sceneIndex, accent = 1) {
            if (!audioContext) return;
            
            const baseFreqs = [60, 80, 50, 100, 70];
            const freq = baseFreqs[beatMode];
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = ['sine', 'triangle', 'square', 'sawtooth', 'sine'][beatMode];
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(freq * 0.4, audioContext.currentTime + 0.15);
            
            gainNode.gain.setValueAtTime(0.2 * accent, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            
            oscillator.connect(gainNode);
            gainNode.connect(masterGain);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.25);
        }

        function startBeatLoops(sceneIndex) {
            stopBeatLoops(sceneIndex);
            
            const settings = sceneSettings[sceneIndex];
            if (settings.beatModes.size === 0) return;
            
            settings.beatModes.forEach(beatMode => {
                const pattern = beatPatterns[beatMode];
                let stepIndex = 0;
                
                function playStep() {
                    if (!beatLoops[sceneIndex].active) return;
                    createBeatSound(beatMode, sceneIndex, pattern.accents[stepIndex]);
                    
                    const interval = pattern.intervals[stepIndex];
                    stepIndex = (stepIndex + 1) % pattern.intervals.length;
                    
                    const timeoutId = setTimeout(playStep, interval);
                    beatLoops[sceneIndex].intervals.push(timeoutId);
                }
                
                beatLoops[sceneIndex].active = true;
                playStep();
            });
        }

        function stopBeatLoops(sceneIndex) {
            beatLoops[sceneIndex].intervals.forEach(id => clearTimeout(id));
            beatLoops[sceneIndex].intervals = [];
            beatLoops[sceneIndex].active = false;
        }

        function updateLayerIndicators(sceneIndex, count) {
            const scene = document.querySelectorAll('.scene')[sceneIndex];
            scene.querySelectorAll('.layer-indicator').forEach((ind, i) => {
                ind.classList.toggle('active', i < count);
            });
        }

        function updateActiveModeDisplay(sceneIndex) {
            const scene = document.querySelectorAll('.scene')[sceneIndex];
            const display = scene.querySelector('.active-modes-display');
            if (!display) return;
            
            const settings = sceneSettings[sceneIndex];
            display.innerHTML = '';
            
            const beatNames = [['Hop', 'Skip', 'Bounce', 'Flutter', 'Gallop'], ['Echo', 'Pulse', 'Crystal', 'Cave', 'Deep'], ['Float', 'Drift', 'Breeze', 'Whisper', 'Lullaby']];
            const melodyNames = [['Sparkle', 'Dream', 'Magic', 'Wish', 'Glow'], ['Mystic', 'Aura', 'Spirit', 'Ethereal', 'Cosmic'], ['Sleepy', 'Dreamy', 'Fluffy', 'Soft', 'Gentle']];
            
            settings.beatModes.forEach(mode => {
                const tag = document.createElement('div');
                tag.className = 'active-mode-tag';
                tag.textContent = 'ü•Å' + beatNames[sceneIndex][mode];
                display.appendChild(tag);
            });
            
            settings.melodyModes.forEach(mode => {
                const tag = document.createElement('div');
                tag.className = 'active-mode-tag';
                tag.textContent = 'üéµ' + melodyNames[sceneIndex][mode];
                display.appendChild(tag);
            });
        }

        function createTouchVisual(x, y, touchPad, layerIndex, sceneIndex) {
            const color = layerColors[sceneIndex][layerIndex % 5];
            
            const indicator = document.createElement('div');
            indicator.className = 'touch-indicator';
            indicator.style.cssText = `left:${x}px;top:${y}px;width:35px;height:35px;background:radial-gradient(circle,${color} 0%,transparent 70%);box-shadow:0 0 12px ${color};`;
            touchPad.appendChild(indicator);
            
            const ring = document.createElement('div');
            ring.className = 'touch-ring';
            ring.style.cssText = `left:${x}px;top:${y}px;width:35px;height:35px;border-color:${color};`;
            touchPad.appendChild(ring);
            
            return { indicator, ring };
        }

        function createSparkle(x, y, touchPad, sceneIndex) {
            const colors = layerColors[sceneIndex];
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.style.cssText = `left:${x + (Math.random()-0.5)*25}px;top:${y + (Math.random()-0.5)*25}px;background:${colors[Math.floor(Math.random()*colors.length)]};`;
            touchPad.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 500);
        }

        // Touch pad handling
        const touchPads = document.querySelectorAll('.touch-pad');
        
        touchPads.forEach((pad) => {
            const sceneIndex = parseInt(pad.dataset.sceneIndex);
            const padTouches = new Map();
            
            function handleTouchStart(e) {
                e.preventDefault();
                initAudio();
                
                const rect = pad.getBoundingClientRect();
                
                for (let touch of e.changedTouches) {
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    const layerIndex = padTouches.size;
                    
                    if (layerIndex < 5) {
                        const visual = createTouchVisual(x, y, pad, layerIndex, sceneIndex);
                        const sound = createContinuousTone(sceneIndex, layerIndex, x, y, rect.width, rect.height);
                        
                        const normX = x / rect.width;
                        const normY = 1 - (y / rect.height);
                        const recordRef = startPadRecording(sceneIndex, layerIndex, x, y, normX, normY);
                        
                        padTouches.set(touch.identifier, { x, y, visual, sound, layerIndex, recordRef, rect });
                        createSparkle(x, y, pad, sceneIndex);
                    }
                }
                
                const count = Math.min(padTouches.size, 5);
                updateLayerIndicators(sceneIndex, count);
                
                if (count > 0 && !beatLoops[sceneIndex].active) {
                    startBeatLoops(sceneIndex);
                }
            }
            
            function handleTouchMove(e) {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    const data = padTouches.get(touch.identifier);
                    if (data) {
                        const x = touch.clientX - data.rect.left;
                        const y = touch.clientY - data.rect.top;
                        
                        data.x = x;
                        data.y = y;
                        
                        data.visual.indicator.style.left = x + 'px';
                        data.visual.indicator.style.top = y + 'px';
                        data.visual.ring.style.left = x + 'px';
                        data.visual.ring.style.top = y + 'px';
                        
                        if (data.sound) {
                            updateTonePosition(data.sound, x, y, data.rect.width, data.rect.height);
                        }
                        
                        const normX = x / data.rect.width;
                        const normY = 1 - (y / data.rect.height);
                        updatePadRecording(data.recordRef, normX, normY, sceneIndex);
                        
                        if (Math.random() < 0.08) createSparkle(x, y, pad, sceneIndex);
                    }
                }
            }
            
            function handleTouchEnd(e) {
                e.preventDefault();
                
                for (let touch of e.changedTouches) {
                    const data = padTouches.get(touch.identifier);
                    if (data) {
                        data.visual.indicator.style.opacity = '0';
                        data.visual.ring.remove();
                        setTimeout(() => data.visual.indicator.remove(), 300);
                        
                        if (data.sound) stopTone(data.sound);
                        endPadRecording(data.recordRef);
                        
                        padTouches.delete(touch.identifier);
                    }
                }
                
                updateLayerIndicators(sceneIndex, padTouches.size);
                if (padTouches.size === 0) stopBeatLoops(sceneIndex);
            }
            
            pad.addEventListener('touchstart', handleTouchStart);
            pad.addEventListener('touchmove', handleTouchMove);
            pad.addEventListener('touchend', handleTouchEnd);
            pad.addEventListener('touchcancel', handleTouchEnd);
            
            // Mouse support
            let mouseData = null;
            
            pad.addEventListener('mousedown', (e) => {
                e.preventDefault();
                initAudio();
                
                const rect = pad.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const visual = createTouchVisual(x, y, pad, 0, sceneIndex);
                const sound = createContinuousTone(sceneIndex, 0, x, y, rect.width, rect.height);
                
                const normX = x / rect.width;
                const normY = 1 - (y / rect.height);
                const recordRef = startPadRecording(sceneIndex, 0, x, y, normX, normY);
                
                mouseData = { x, y, visual, sound, rect, recordRef };
                
                updateLayerIndicators(sceneIndex, 1);
                startBeatLoops(sceneIndex);
                createSparkle(x, y, pad, sceneIndex);
            });
            
            pad.addEventListener('mousemove', (e) => {
                if (!mouseData) return;
                
                const x = e.clientX - mouseData.rect.left;
                const y = e.clientY - mouseData.rect.top;
                
                mouseData.visual.indicator.style.left = x + 'px';
                mouseData.visual.indicator.style.top = y + 'px';
                mouseData.visual.ring.style.left = x + 'px';
                mouseData.visual.ring.style.top = y + 'px';
                
                if (mouseData.sound) {
                    updateTonePosition(mouseData.sound, x, y, mouseData.rect.width, mouseData.rect.height);
                }
                
                const normX = x / mouseData.rect.width;
                const normY = 1 - (y / mouseData.rect.height);
                updatePadRecording(mouseData.recordRef, normX, normY, sceneIndex);
                
                if (Math.random() < 0.08) createSparkle(x, y, pad, sceneIndex);
            });
            
            function endMouse() {
                if (mouseData) {
                    mouseData.visual.indicator.remove();
                    mouseData.visual.ring.remove();
                    if (mouseData.sound) stopTone(mouseData.sound);
                    endPadRecording(mouseData.recordRef);
                    
                    mouseData = null;
                    updateLayerIndicators(sceneIndex, 0);
                    stopBeatLoops(sceneIndex);
                }
            }
            
            pad.addEventListener('mouseup', endMouse);
            pad.addEventListener('mouseleave', endMouse);
        });

        // Mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                initAudio();
                
                const sceneEl = btn.closest('.scene');
                const sceneIndex = parseInt(sceneEl.dataset.scene);
                const settings = sceneSettings[sceneIndex];
                
                if (btn.classList.contains('beat-btn')) {
                    const beatMode = parseInt(btn.dataset.beat);
                    if (settings.beatModes.has(beatMode)) {
                        settings.beatModes.delete(beatMode);
                        btn.classList.remove('active');
                    } else {
                        settings.beatModes.add(beatMode);
                        btn.classList.add('active');
                        createBeatSound(beatMode, sceneIndex, 1);
                    }
                    if (beatLoops[sceneIndex].active) startBeatLoops(sceneIndex);
                } else if (btn.classList.contains('melody-btn')) {
                    const melodyMode = parseInt(btn.dataset.melody);
                    if (settings.melodyModes.has(melodyMode)) {
                        settings.melodyModes.delete(melodyMode);
                        btn.classList.remove('active');
                    } else {
                        settings.melodyModes.add(melodyMode);
                        btn.classList.add('active');
                    }
                }
                
                updateActiveModeDisplay(sceneIndex);
            });
        });

        // Mixer functionality
        const tracksContainer = document.getElementById('tracksContainer');
        const emptyState = document.getElementById('emptyState');
        const fileInput = document.getElementById('fileInput');

        function createChannelGrids(track) {
            let html = '<div class="channel-grid">';
            
            const beatSteps = new Set();
            if (track.channels && track.channels.beats) {
                track.channels.beats.events.forEach(e => beatSteps.add(Math.floor(e.step)));
            } else if (track.drums) {
                track.drums.forEach(d => beatSteps.add(Math.floor(d.step)));
            }
            
            html += '<div class="channel-row"><span class="channel-label">ü•Å</span><div class="step-grid">';
            for (let i = 0; i < Math.min(TOTAL_STEPS, 32); i++) {
                const hasEvent = beatSteps.has(i);
                const isBeatMarker = i % 4 === 0;
                html += `<div class="step-cell${hasEvent ? ' has-event' : ''}${isBeatMarker ? ' beat-marker' : ''}"></div>`;
            }
            html += '</div></div>';
            
            const harmonyChannels = track.channels ? track.channels.harmony : [];
            const legacyPads = track.pads || [];
            
            const numChannels = Math.max(
                harmonyChannels.length,
                legacyPads.length > 0 ? Math.max(...legacyPads.map(p => p.fingerIndex || 0)) + 1 : 0
            );
            
            for (let ch = 0; ch < Math.min(numChannels, MAX_HARMONY_CHANNELS); ch++) {
                const channelData = harmonyChannels.find(c => c.channelIndex === ch);
                const legacyPad = legacyPads.find(p => (p.fingerIndex || 0) === ch);
                
                const eventSteps = new Set();
                const sustainSteps = new Set();
                
                if (channelData) {
                    channelData.notes.forEach(note => {
                        note.events.forEach(e => eventSteps.add(Math.floor(e.step)));
                        if (note.endStep !== null) {
                            for (let s = Math.floor(note.startStep); s <= Math.floor(note.endStep); s++) {
                                sustainSteps.add(s);
                            }
                        }
                    });
                } else if (legacyPad) {
                    legacyPad.steps.forEach(s => eventSteps.add(Math.floor(s.step)));
                    if (legacyPad.endStep !== undefined) {
                        for (let s = Math.floor(legacyPad.startStep || 0); s <= Math.floor(legacyPad.endStep); s++) {
                            sustainSteps.add(s);
                        }
                    }
                }
                
                const emojis = ['üéµ', 'üé∂', '‚ú®', 'üí´', 'üåü'];
                html += `<div class="channel-row"><span class="channel-label">${emojis[ch]}</span><div class="step-grid">`;
                for (let i = 0; i < Math.min(TOTAL_STEPS, 32); i++) {
                    const hasEvent = eventSteps.has(i);
                    const hasSustain = sustainSteps.has(i) && !hasEvent;
                    const isBeatMarker = i % 4 === 0;
                    html += `<div class="step-cell${hasEvent ? ' has-event' : ''}${hasSustain ? ' has-sustain' : ''}${isBeatMarker ? ' beat-marker' : ''}"></div>`;
                }
                html += '</div></div>';
            }
            
            html += '</div>';
            return html;
        }

        function createTrackElement(track, index) {
            const trackEl = document.createElement('div');
            trackEl.className = 'track-item';
            trackEl.draggable = true;
            trackEl.dataset.trackIndex = index;
            
            let beatCount = 0;
            let harmonyCount = 0;
            
            if (track.channels) {
                beatCount = track.channels.beats.events.length;
                harmonyCount = track.channels.harmony.reduce((sum, ch) => sum + ch.notes.length, 0);
            } else {
                beatCount = track.drums ? track.drums.length : 0;
                harmonyCount = track.pads ? track.pads.length : 0;
            }
            
            trackEl.innerHTML = `
                <div class="track-header">
                    <div>
                        <span class="track-name">${track.name || 'Track ' + (index + 1)}</span>
                        <div class="track-info">${beatCount} beats, ${harmonyCount} notes</div>
                    </div>
                    <div class="track-controls">
                        <button class="track-btn track-add-master" data-index="${index}" title="Add to Master">‚ûï</button>
                        <button class="track-btn track-play" data-index="${index}">‚ñ∂</button>
                        <button class="track-btn track-delete" data-index="${index}">‚úï</button>
                    </div>
                </div>
                ${createChannelGrids(track)}
                <div class="trim-controls">
                    <div class="stretch-control">
                        <span class="stretch-label">L</span>
                        <input type="range" class="stretch-slider" data-index="${index}" data-end="left" min="-2" max="2" step="0.1" value="0">
                    </div>
                    <div class="stretch-control">
                        <span class="stretch-label">R</span>
                        <input type="range" class="stretch-slider" data-index="${index}" data-end="right" min="-2" max="2" step="0.1" value="0">
                    </div>
                    <select class="curve-select" data-index="${index}">
                        <option value="linear">Lin</option>
                        <option value="log">Log</option>
                        <option value="exp">Exp</option>
                    </select>
                    <button class="autotune-btn${track.autoTunePlayback ? ' active' : ''}" data-index="${index}">üéµ</button>
                    <button class="autorhythm-btn${track.autoRhythmPlayback ? ' active' : ''}" data-index="${index}">ü•Å</button>
                </div>
            `;
            
            // Drag events for reordering tracks
            trackEl.addEventListener('dragstart', (e) => {
                draggedTrackIndex = index;
                trackEl.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            
            trackEl.addEventListener('dragend', () => {
                trackEl.classList.remove('dragging');
                draggedTrackIndex = null;
                document.querySelectorAll('.track-item').forEach(el => el.classList.remove('drag-over'));
            });
            
            trackEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (draggedTrackIndex !== null && draggedTrackIndex !== index) {
                    trackEl.classList.add('drag-over');
                }
            });
            
            trackEl.addEventListener('dragleave', () => {
                trackEl.classList.remove('drag-over');
            });
            
            trackEl.addEventListener('drop', (e) => {
                e.preventDefault();
                trackEl.classList.remove('drag-over');
                if (draggedTrackIndex !== null && draggedTrackIndex !== index) {
                    const movedTrack = mixerTracks.splice(draggedTrackIndex, 1)[0];
                    mixerTracks.splice(index, 0, movedTrack);
                    renderTracks();
                }
            });
            
            return trackEl;
        }

        function renderTracks() {
            tracksContainer.innerHTML = '';
            if (mixerTracks.length === 0) {
                tracksContainer.appendChild(emptyState);
            } else {
                mixerTracks.forEach((track, index) => {
                    tracksContainer.appendChild(createTrackElement(track, index));
                });
            }
            attachTrackListeners();
        }

        function attachTrackListeners() {
            document.querySelectorAll('.track-play').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    playTrack(mixerTracks[index]);
                });
            });
            
            document.querySelectorAll('.track-delete').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    mixerTracks.splice(index, 1);
                    renderTracks();
                    updateMasterPanelVisibility();
                });
            });
            
            document.querySelectorAll('.track-add-master').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    addTrackToMaster(index);
                });
            });
            
            document.querySelectorAll('.autotune-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    mixerTracks[index].autoTunePlayback = !mixerTracks[index].autoTunePlayback;
                    btn.classList.toggle('active', mixerTracks[index].autoTunePlayback);
                });
            });
            
            document.querySelectorAll('.autorhythm-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const index = parseInt(btn.dataset.index);
                    mixerTracks[index].autoRhythmPlayback = !mixerTracks[index].autoRhythmPlayback;
                    btn.classList.toggle('active', mixerTracks[index].autoRhythmPlayback);
                });
            });
            
            document.querySelectorAll('.stretch-slider').forEach(slider => {
                slider.addEventListener('input', () => {
                    const index = parseInt(slider.dataset.index);
                    const end = slider.dataset.end;
                    if (!mixerTracks[index].stretch) mixerTracks[index].stretch = {};
                    mixerTracks[index].stretch[end] = parseFloat(slider.value);
                });
            });
            
            document.querySelectorAll('.curve-select').forEach(select => {
                select.addEventListener('change', () => {
                    const index = parseInt(select.dataset.index);
                    mixerTracks[index].stretchCurve = select.value;
                });
            });
        }

        function applyStretch(step, track, totalSteps) {
            if (!track.stretch) return step;
            
            const leftStretch = track.stretch.left || 0;
            const rightStretch = track.stretch.right || 0;
            const curve = track.stretchCurve || 'linear';
            
            let t = step / totalSteps;
            
            if (curve === 'log') t = Math.log(1 + t * 9) / Math.log(10);
            else if (curve === 'exp') t = (Math.pow(10, t) - 1) / 9;
            
            const leftInfluence = 1 - t;
            const rightInfluence = t;
            const stretchFactor = 1 + (leftStretch * leftInfluence) + (rightStretch * rightInfluence);
            
            return step * Math.max(0.1, stretchFactor);
        }

        function createSustainedNote(freq, filterValue, sceneIndex = 0) {
            const config = synthConfigs[sceneIndex];
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.type = config.types[0];
            oscillator.frequency.value = freq;
            
            filter.type = 'lowpass';
            filter.frequency.value = filterValue || 2000;
            filter.Q.value = 2;
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.12, audioContext.currentTime + 0.02);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(masterGain);
            oscillator.start();
            
            return { oscillator, gainNode, filter };
        }

        function updateSustainedNote(noteData, freq, filterValue) {
            if (!noteData) return;
            noteData.oscillator.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.03);
            noteData.filter.frequency.setTargetAtTime(filterValue, audioContext.currentTime, 0.03);
        }

        function stopSustainedNote(noteData) {
            if (!noteData) return;
            noteData.gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.05);
            setTimeout(() => { try { noteData.oscillator.stop(); } catch(e) {} }, 150);
        }

        function playTrack(track, timeOffset = 0) {
            initAudio();
            
            const autoRhythm = track.autoRhythmPlayback;
            const autoTune = track.autoTunePlayback;
            const totalSteps = track.totalSteps || TOTAL_STEPS;
            const cropStart = track.cropStart || 0;
            const cropEnd = track.cropEnd || totalSteps;
            
            if (track.channels) {
                track.channels.beats.events.forEach(event => {
                    let step = event.step;
                    if (step < cropStart || step > cropEnd) return;
                    step = step - cropStart;
                    if (autoRhythm) step = Math.round(step);
                    step = applyStretch(step, track, cropEnd - cropStart);
                    
                    const time = stepToTime(step) + timeOffset;
                    if (time >= 0) {
                        const id = setTimeout(() => playDrumSound(event.drumIndex, false), time);
                        playbackTimeouts.push(id);
                    }
                });
                
                track.channels.harmony.forEach(channel => {
                    channel.notes.forEach(note => {
                        if (note.startStep > cropEnd || (note.endStep !== null && note.endStep < cropStart)) return;
                        
                        const noteId = `${channel.channelIndex}-${note.startStep}-${Date.now()}`;
                        
                        let startStep = Math.max(note.startStep, cropStart) - cropStart;
                        if (autoRhythm) startStep = Math.round(startStep);
                        startStep = applyStretch(startStep, track, cropEnd - cropStart);
                        
                        const startTime = stepToTime(startStep) + timeOffset;
                        
                        if (startTime >= 0) {
                            const startId = setTimeout(() => {
                                const firstEvent = note.events[0];
                                let freq = firstEvent.freq;
                                if (autoTune) freq = quantizeToScale(freq);
                                
                                const sustainedNote = createSustainedNote(freq, firstEvent.filter, channel.sceneIndex);
                                activeSustainedNotes.set(noteId, sustainedNote);
                            }, startTime);
                            playbackTimeouts.push(startId);
                        }
                        
                        note.events.forEach((event, idx) => {
                            if (idx === 0) return;
                            if (event.step < cropStart || event.step > cropEnd) return;
                            
                            let step = event.step - cropStart;
                            if (autoRhythm) step = Math.round(step);
                            step = applyStretch(step, track, cropEnd - cropStart);
                            
                            const time = stepToTime(step) + timeOffset;
                            if (time >= 0) {
                                const updateId = setTimeout(() => {
                                    const sustainedNote = activeSustainedNotes.get(noteId);
                                    if (sustainedNote) {
                                        let freq = event.freq;
                                        if (autoTune) freq = quantizeToScale(freq);
                                        updateSustainedNote(sustainedNote, freq, event.filter);
                                    }
                                }, time);
                                playbackTimeouts.push(updateId);
                            }
                        });
                        
                        if (note.endStep !== null) {
                            let endStep = Math.min(note.endStep, cropEnd) - cropStart;
                            if (autoRhythm) endStep = Math.round(endStep);
                            endStep = applyStretch(endStep, track, cropEnd - cropStart);
                            
                            const endTime = stepToTime(endStep) + timeOffset;
                            if (endTime >= 0) {
                                const endId = setTimeout(() => {
                                    const sustainedNote = activeSustainedNotes.get(noteId);
                                    if (sustainedNote) {
                                        stopSustainedNote(sustainedNote);
                                        activeSustainedNotes.delete(noteId);
                                    }
                                }, endTime);
                                playbackTimeouts.push(endId);
                            }
                        }
                    });
                });
            } else {
                // Legacy format support
                if (track.drums) {
                    track.drums.forEach(drum => {
                        let step = drum.step;
                        if (step < cropStart || step > cropEnd) return;
                        step = step - cropStart;
                        if (autoRhythm) step = Math.round(step);
                        step = applyStretch(step, track, cropEnd - cropStart);
                        
                        const time = stepToTime(step) + timeOffset;
                        if (time >= 0) {
                            const id = setTimeout(() => playDrumSound(drum.drumIndex, false), time);
                            playbackTimeouts.push(id);
                        }
                    });
                }
                
                if (track.pads) {
                    track.pads.forEach((padData, padIdx) => {
                        const noteId = `legacy-${padIdx}-${Date.now()}`;
                        const hasMultipleSteps = padData.steps.length > 1;
                        const hasSustain = padData.endStep !== undefined && padData.endStep > padData.startStep;
                        
                        if (hasSustain || hasMultipleSteps) {
                            let startStep = padData.startStep || padData.steps[0].step;
                            if (startStep > cropEnd) return;
                            startStep = Math.max(startStep, cropStart) - cropStart;
                            if (autoRhythm) startStep = Math.round(startStep);
                            startStep = applyStretch(startStep, track, cropEnd - cropStart);
                            
                            const startTime = stepToTime(startStep) + timeOffset;
                            
                            if (startTime >= 0) {
                                const startId = setTimeout(() => {
                                    const firstEvent = padData.steps[0];
                                    let freq = firstEvent.freq;
                                    if (autoTune) freq = quantizeToScale(freq);
                                    
                                    const sustainedNote = createSustainedNote(freq, firstEvent.filter, padData.sceneIndex || 0);
                                    activeSustainedNotes.set(noteId, sustainedNote);
                                }, startTime);
                                playbackTimeouts.push(startId);
                            }
                            
                            padData.steps.forEach((stepData, idx) => {
                                if (idx === 0) return;
                                if (stepData.step < cropStart || stepData.step > cropEnd) return;
                                
                                let step = stepData.step - cropStart;
                                if (autoRhythm) step = Math.round(step);
                                step = applyStretch(step, track, cropEnd - cropStart);
                                
                                const time = stepToTime(step) + timeOffset;
                                if (time >= 0) {
                                    const updateId = setTimeout(() => {
                                        const sustainedNote = activeSustainedNotes.get(noteId);
                                        if (sustainedNote) {
                                            let freq = stepData.freq;
                                            if (autoTune) freq = quantizeToScale(freq);
                                            updateSustainedNote(sustainedNote, freq, stepData.filter);
                                        }
                                    }, time);
                                    playbackTimeouts.push(updateId);
                                }
                            });
                            
                            if (padData.endStep !== undefined) {
                                let endStep = Math.min(padData.endStep, cropEnd) - cropStart;
                                if (autoRhythm) endStep = Math.round(endStep);
                                endStep = applyStretch(endStep, track, cropEnd - cropStart);
                                
                                const endTime = stepToTime(endStep) + timeOffset;
                                if (endTime >= 0) {
                                    const endId = setTimeout(() => {
                                        const sustainedNote = activeSustainedNotes.get(noteId);
                                        if (sustainedNote) {
                                            stopSustainedNote(sustainedNote);
                                            activeSustainedNotes.delete(noteId);
                                        }
                                    }, endTime);
                                    playbackTimeouts.push(endId);
                                }
                            }
                        } else {
                            padData.steps.forEach(stepData => {
                                if (stepData.step < cropStart || stepData.step > cropEnd) return;
                                
                                let step = stepData.step - cropStart;
                                if (autoRhythm) step = Math.round(step);
                                step = applyStretch(step, track, cropEnd - cropStart);
                                
                                const time = stepToTime(step) + timeOffset;
                                if (time >= 0) {
                                    const id = setTimeout(() => {
                                        let freq = stepData.freq;
                                        if (autoTune) freq = quantizeToScale(freq);
                                        
                                        const osc = audioContext.createOscillator();
                                        const gain = audioContext.createGain();
                                        const filter = audioContext.createBiquadFilter();
                                        
                                        osc.frequency.value = freq;
                                        osc.type = 'sine';
                                        
                                        filter.type = 'lowpass';
                                        filter.frequency.value = stepData.filter || 2000;
                                        
                                        gain.gain.setValueAtTime(0.12, audioContext.currentTime);
                                        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.15);
                                        
                                        osc.connect(filter);
                                        filter.connect(gain);
                                        gain.connect(masterGain);
                                        osc.start();
                                        osc.stop(audioContext.currentTime + 0.2);
                                    }, time);
                                    playbackTimeouts.push(id);
                                }
                            });
                        }
                    });
                }
            }
        }

        document.getElementById('importBtn').addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        if (data.tracks) {
                            data.tracks.forEach(t => {
                                t.name = t.name || file.name.replace('.json', '');
                                mixerTracks.push(t);
                            });
                        } else {
                            data.name = data.name || file.name.replace('.json', '');
                            mixerTracks.push(data);
                        }
                        
                        renderTracks();
                        updateMasterPanelVisibility();
                    } catch (err) {
                        console.error('Invalid JSON:', err);
                    }
                };
                reader.readAsText(file);
            });
            fileInput.value = '';
        });

        document.getElementById('playAllBtn').addEventListener('click', () => {
            initAudio();
            mixerTracks.forEach(track => playTrack(track));
        });

        document.getElementById('stopAllBtn').addEventListener('click', () => {
            stopAllPlayback();
        });

        document.getElementById('clearAllBtn').addEventListener('click', () => {
            mixerTracks = [];
            renderTracks();
            updateMasterPanelVisibility();
        });

        // Master Channel Functions
        function updateMasterPanelVisibility() {
            const panel = document.getElementById('masterPanel');
            if (currentScene === 3) {
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }

        function addTrackToMaster(trackIndex) {
            const track = mixerTracks[trackIndex];
            if (!track) return;
            
            const clip = {
                trackIndex,
                name: track.name || `Track ${trackIndex + 1}`,
                cropStart: track.cropStart || 0,
                cropEnd: track.cropEnd || (track.totalSteps || TOTAL_STEPS),
                trackData: JSON.parse(JSON.stringify(track))
            };
            
            masterClips.push(clip);
            renderMasterTimeline();
        }

        function getClipDuration(clip) {
            return clip.cropEnd - clip.cropStart;
        }

        function renderMasterTimeline() {
            const inner = document.getElementById('masterTimelineInner');
            const empty = document.getElementById('masterEmpty');
            
            if (masterClips.length === 0) {
                inner.innerHTML = '';
                inner.appendChild(empty);
                return;
            }
            
            inner.innerHTML = '';
            
            masterClips.forEach((clip, index) => {
                const clipEl = document.createElement('div');
                clipEl.className = 'master-clip' + (index === selectedClipIndex ? ' selected' : '');
                clipEl.dataset.clipIndex = index;
                
                const duration = getClipDuration(clip);
                const durationSec = (stepToTime(duration) / 1000).toFixed(1);
                
                clipEl.innerHTML = `
                    <div class="master-clip-name">${clip.name}</div>
                    <div class="master-clip-duration">${durationSec}s</div>
                    <button class="master-clip-remove" data-index="${index}">‚úï</button>
                    <div class="crop-handles">
                        <div class="crop-handle crop-left" data-index="${index}" data-side="left"></div>
                        <div class="crop-handle crop-right" data-index="${index}" data-side="right"></div>
                    </div>
                `;
                
                // Clip selection
                clipEl.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('master-clip-remove') && !e.target.classList.contains('crop-handle')) {
                        selectedClipIndex = index;
                        renderMasterTimeline();
                    }
                });
                
                // Drag for reordering
                clipEl.draggable = true;
                
                clipEl.addEventListener('dragstart', (e) => {
                    draggedClipIndex = index;
                    clipEl.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                clipEl.addEventListener('dragend', () => {
                    clipEl.classList.remove('dragging');
                    draggedClipIndex = null;
                });
                
                clipEl.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (draggedClipIndex !== null && draggedClipIndex !== index) {
                        clipEl.style.borderColor = '#fff';
                    }
                });
                
                clipEl.addEventListener('dragleave', () => {
                    clipEl.style.borderColor = '';
                });
                
                clipEl.addEventListener('drop', (e) => {
                    e.preventDefault();
                    clipEl.style.borderColor = '';
                    if (draggedClipIndex !== null && draggedClipIndex !== index) {
                        const movedClip = masterClips.splice(draggedClipIndex, 1)[0];
                        masterClips.splice(index, 0, movedClip);
                        renderMasterTimeline();
                    }
                });
                
                inner.appendChild(clipEl);
            });
            
            // Attach remove handlers
            inner.querySelectorAll('.master-clip-remove').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    masterClips.splice(idx, 1);
                    if (selectedClipIndex >= masterClips.length) selectedClipIndex = masterClips.length - 1;
                    renderMasterTimeline();
                });
            });
            
            // Attach crop handlers
            inner.querySelectorAll('.crop-handle').forEach(handle => {
                const handleTouch = (startE) => {
                    startE.preventDefault();
                    startE.stopPropagation();
                    
                    const idx = parseInt(handle.dataset.index);
                    const side = handle.dataset.side;
                    const clip = masterClips[idx];
                    const startX = startE.type === 'touchstart' ? startE.touches[0].clientX : startE.clientX;
                    const startCropStart = clip.cropStart;
                    const startCropEnd = clip.cropEnd;
                    const maxSteps = clip.trackData.totalSteps || TOTAL_STEPS;
                    
                    const onMove = (moveE) => {
                        const currentX = moveE.type === 'touchmove' ? moveE.touches[0].clientX : moveE.clientX;
                        const deltaX = currentX - startX;
                        const stepsPerPixel = 0.5;
                        const deltaSteps = Math.round(deltaX * stepsPerPixel);
                        
                        if (side === 'left') {
                            clip.cropStart = Math.max(0, Math.min(startCropEnd - 4, startCropStart + deltaSteps));
                        } else {
                            clip.cropEnd = Math.max(startCropStart + 4, Math.min(maxSteps, startCropEnd + deltaSteps));
                        }
                        
                        clip.trackData.cropStart = clip.cropStart;
                        clip.trackData.cropEnd = clip.cropEnd;
                        renderMasterTimeline();
                    };
                    
                    const onEnd = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onEnd);
                        document.removeEventListener('touchmove', onMove);
                        document.removeEventListener('touchend', onEnd);
                    };
                    
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                    document.addEventListener('touchmove', onMove);
                    document.addEventListener('touchend', onEnd);
                };
                
                handle.addEventListener('mousedown', handleTouch);
                handle.addEventListener('touchstart', handleTouch);
            });
        }

        // Master Play
        document.getElementById('masterPlayBtn').addEventListener('click', () => {
            initAudio();
            stopAllPlayback();
            
            let timeOffset = 0;
            masterClips.forEach(clip => {
                playTrack(clip.trackData, timeOffset);
                const duration = getClipDuration(clip);
                timeOffset += stepToTime(duration);
            });
        });

        // Master Download with CC0 License
        document.getElementById('masterDownloadBtn').addEventListener('click', () => {
            if (masterClips.length === 0) {
                alert('Add clips to master channel first!');
                return;
            }
            
            const masterExport = {
                version: "3.0",
                license: {
                    type: "CC0-1.0",
                    name: "Creative Commons Zero v1.0 Universal",
                    url: "https://creativecommons.org/publicdomain/zero/1.0/",
                    dedication: "To the extent possible under law, the creator has waived all copyright and related or neighboring rights to this work. This work is published from the United States.",
                    legalCode: "https://creativecommons.org/publicdomain/zero/1.0/legalcode"
                },
                createdWith: "üåà Rainbow Unicorn Bunny Fluffcore üê∞",
                createdAt: new Date().toISOString(),
                bpm: BPM,
                master: {
                    clips: masterClips.map(clip => ({
                        name: clip.name,
                        cropStart: clip.cropStart,
                        cropEnd: clip.cropEnd,
                        track: clip.trackData
                    }))
                },
                tracks: mixerTracks
            };
            
            const json = JSON.stringify(masterExport, null, 2);
            downloadJson(json, 'fluffcore-master-cc0');
        });

        // Master Clear
        document.getElementById('masterClearBtn').addEventListener('click', () => {
            masterClips = [];
            selectedClipIndex = -1;
            renderMasterTimeline();
        });

        // Scene navigation
        const sceneContainer = document.getElementById('sceneContainer');
        const dots = document.querySelectorAll('.dot');
        
        function updateScene(index) {
            currentScene = Math.max(0, Math.min(3, index));
            sceneContainer.style.transform = `translateX(-${currentScene * 25}%)`;
            dots.forEach((dot, i) => dot.classList.toggle('active', i === currentScene));
            updateMasterPanelVisibility();
        }
        
        let swipeStartX = 0;
        let isSwiping = false;
        
        document.querySelector('.app-container').addEventListener('touchstart', (e) => {
            if (e.target.closest('.touch-pad') || e.target.closest('.mode-btn') || e.target.closest('.drum-btn') || e.target.closest('.ctrl-btn') || e.target.closest('.mixer-container') || e.target.closest('.master-panel')) return;
            swipeStartX = e.touches[0].clientX;
            isSwiping = false;
        });
        
        document.querySelector('.app-container').addEventListener('touchmove', (e) => {
            if (e.target.closest('.touch-pad') || e.target.closest('.mode-btn') || e.target.closest('.drum-btn') || e.target.closest('.ctrl-btn') || e.target.closest('.mixer-container') || e.target.closest('.master-panel')) return;
            if (Math.abs(e.touches[0].clientX - swipeStartX) > 30) isSwiping = true;
        });
        
        document.querySelector('.app-container').addEventListener('touchend', (e) => {
            if (e.target.closest('.touch-pad') || e.target.closest('.mode-btn') || e.target.closest('.drum-btn') || e.target.closest('.ctrl-btn') || e.target.closest('.mixer-container') || e.target.closest('.master-panel')) return;
            if (isSwiping) {
                const deltaX = e.changedTouches[0].clientX - swipeStartX;
                if (deltaX > 50) updateScene(currentScene - 1);
                else if (deltaX < -50) updateScene(currentScene + 1);
            }
        });
        
        dots.forEach((dot, index) => {
            dot.addEventListener('click', () => updateScene(index));
        });
        
        // Initialize
        updateScene(0);
        [0, 1, 2].forEach(i => updateActiveModeDisplay(i));
        renderTracks();
        renderMasterTimeline();
    </script>
</body>
</html>
