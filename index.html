<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0">
    <title>üåà Rainbow Unicorn Bunny Fluffcore üê∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .app-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .drumkit-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: linear-gradient(135deg, rgba(255,107,107,0.95), rgba(255,182,193,0.95), rgba(168,237,234,0.95));
            padding: 5px 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border-bottom: 3px solid rgba(255,255,255,0.5);
            flex-wrap: wrap;
        }

        .drum-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .drum-btn:active, .drum-btn.playing {
            transform: scale(0.85);
        }

        .ctrl-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            font-size: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .record-btn { background: linear-gradient(135deg, #ff4757, #c0392b); color: white; }
        .record-btn.recording { animation: recordPulse 0.5s ease-in-out infinite; box-shadow: 0 0 15px #ff4757; }
        .stop-btn { background: linear-gradient(135deg, #2f3542, #57606f); color: white; }
        .export-btn { background: linear-gradient(135deg, #2ed573, #1e90ff); color: white; }
        .autobeat-btn { background: linear-gradient(135deg, #ffa502, #ff6348); color: white; font-size: 0.6rem; }
        .autotune-btn-top { background: linear-gradient(135deg, #a55eea, #8854d0); color: white; font-size: 0.6rem; }
        .autobeat-btn.active, .autotune-btn-top.active { box-shadow: 0 0 12px currentColor; transform: scale(1.1); }

        @keyframes recordPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .drum-0 { background: linear-gradient(135deg, #ff6b6b, #ee5a5a); }
        .drum-1 { background: linear-gradient(135deg, #feca57, #f9b234); }
        .drum-2 { background: linear-gradient(135deg, #48dbfb, #2ec4ea); }
        .drum-3 { background: linear-gradient(135deg, #ff9ff3, #f368e0); }
        .drum-4 { background: linear-gradient(135deg, #a55eea, #8854d0); }
        .drum-5 { background: linear-gradient(135deg, #1dd1a1, #10ac84); }
        .drum-6 { background: linear-gradient(135deg, #5f27cd, #4a1fb8); }
        .drum-7 { background: linear-gradient(135deg, #ff9f43, #ee8620); }
        .drum-8 { background: linear-gradient(135deg, #00d2d3, #00b5b6); }
        .drum-9 { background: linear-gradient(135deg, #fd79a8, #e84393); }

        .scene-container {
            display: flex;
            width: 500%;
            height: 100%;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            padding-top: 44px;
        }

        .scene {
            width: 20%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .scene-1 { background: linear-gradient(180deg, #ff9a9e 0%, #fecfef 50%, #a8edea 100%); }
        .scene-2 { background: linear-gradient(180deg, #667eea 0%, #764ba2 50%, #f093fb 100%); }
        .scene-3 { background: linear-gradient(180deg, #a1c4fd 0%, #c2e9fb 50%, #fff1eb 100%); }
        .scene-4 { background: linear-gradient(180deg, #434343 0%, #1a1a2e 50%, #16213e 100%); }
        .scene-5 { background: linear-gradient(180deg, #11998e 0%, #38ef7d 30%, #a8e063 70%, #56ab2f 100%); }

        .header {
            padding: 3px 8px;
            text-align: center;
        }

        .scene-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .scene-subtitle {
            font-size: 0.55rem;
            color: rgba(255,255,255,0.9);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 3px;
            padding: 2px 5px;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 3px 5px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-size: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.6;
        }

        .mode-btn.active {
            opacity: 1;
            border-color: white;
        }

        .beat-btn { background: linear-gradient(135deg, #ff6b6b, #feca57); color: white; }
        .melody-btn { background: linear-gradient(135deg, #5f27cd, #48dbfb); color: white; }

        .touch-pad {
            flex: 1;
            margin: 3px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 40px rgba(0,0,0,0.1), 0 8px 25px rgba(0,0,0,0.2);
        }

        .scene-1 .touch-pad { background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,182,193,0.3)); border: 2px solid rgba(255,255,255,0.5); }
        .scene-2 .touch-pad { background: linear-gradient(135deg, rgba(138,43,226,0.3), rgba(75,0,130,0.3)); border: 2px solid rgba(200,150,255,0.5); }
        .scene-3 .touch-pad { background: linear-gradient(135deg, rgba(255,255,255,0.4), rgba(200,230,255,0.3)); border: 2px solid rgba(255,255,255,0.6); }

        .touch-indicator {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .touch-ring {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            border: 3px solid rgba(255,255,255,0.5);
            animation: ringPulse 1s ease-out infinite;
        }

        @keyframes ringPulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        .layer-display {
            display: flex;
            justify-content: center;
            gap: 3px;
            padding: 3px;
        }

        .layer-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            opacity: 0.3;
            transform: scale(0.7);
        }

        .layer-indicator.active {
            opacity: 1;
            transform: scale(1);
        }

        .scene-dots {
            position: fixed;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: rgba(255,255,255,0.5);
            cursor: pointer;
        }

        .dot.active {
            background: white;
            transform: scale(1.3);
        }

        .floating-element {
            position: absolute;
            pointer-events: none;
            animation: float 3s ease-in-out infinite;
            opacity: 0.5;
            font-size: 1rem;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        .sparkle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: white;
            border-radius: 50%;
            animation: sparkle 0.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes sparkle {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .xy-label {
            position: absolute;
            color: white;
            font-size: 0.45rem;
            opacity: 0.5;
            pointer-events: none;
        }

        .xy-label.pitch { top: 2px; left: 50%; transform: translateX(-50%); }
        .xy-label.pitch-low { bottom: 2px; left: 50%; transform: translateX(-50%); }
        .xy-label.tone { left: 2px; top: 50%; transform: translateY(-50%) rotate(-90deg); }
        .xy-label.tone-bright { right: 2px; top: 50%; transform: translateY(-50%) rotate(90deg); }

        .active-modes-display {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 4px;
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
            pointer-events: none;
        }

        .active-mode-tag {
            padding: 1px 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            font-size: 0.45rem;
            color: white;
        }

        .record-indicator {
            position: fixed;
            top: 48px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,0,0,0.9);
            color: white;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.6rem;
            font-weight: bold;
            display: none;
            z-index: 300;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .record-indicator.visible { display: block; }

        .mixer-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 6px;
            padding-bottom: 140px;
            gap: 6px;
            overflow-y: auto;
        }

        .mixer-header {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mixer-btn {
            padding: 5px 8px;
            border: none;
            border-radius: 6px;
            font-size: 0.55rem;
            font-weight: bold;
            cursor: pointer;
            color: white;
        }

        .import-btn { background: linear-gradient(135deg, #6c5ce7, #a29bfe); }
        .play-all-btn { background: linear-gradient(135deg, #00b894, #55efc4); }
        .stop-all-btn { background: linear-gradient(135deg, #d63031, #ff7675); }
        .clear-btn { background: linear-gradient(135deg, #636e72, #b2bec3); }

        .tracks-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-y: auto;
        }

        .track-item {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: grab;
            transition: all 0.2s;
        }

        .track-item.dragging { opacity: 0.5; transform: scale(0.95); }
        .track-item.drag-over { border-color: #a29bfe; box-shadow: 0 0 10px rgba(162, 155, 254, 0.5); }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .track-name { color: white; font-size: 0.6rem; font-weight: bold; }
        .track-info { color: rgba(255,255,255,0.6); font-size: 0.5rem; }

        .track-controls { display: flex; gap: 3px; }

        .track-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 50%;
            font-size: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .track-play { background: #00b894; color: white; }
        .track-delete { background: #d63031; color: white; }
        .track-add-master { background: #6c5ce7; color: white; }

        .channel-grid { display: flex; flex-direction: column; gap: 2px; margin-bottom: 4px; }
        .channel-row { display: flex; align-items: center; gap: 3px; }
        .channel-label { width: 20px; font-size: 0.45rem; color: rgba(255,255,255,0.7); }

        .step-grid {
            display: flex;
            gap: 1px;
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            overflow: hidden;
            flex: 1;
        }

        .step-cell { flex: 1; background: rgba(255,255,255,0.1); position: relative; }
        .step-cell.has-event { background: linear-gradient(135deg, #74b9ff, #0984e3); }
        .step-cell.has-sustain { background: linear-gradient(135deg, #a29bfe, #6c5ce7); }
        .step-cell.beat-marker { border-left: 1px solid rgba(255,255,255,0.3); }

        .trim-controls { display: flex; gap: 4px; align-items: center; flex-wrap: wrap; }
        .stretch-control { display: flex; align-items: center; gap: 2px; }
        .stretch-label { color: rgba(255,255,255,0.7); font-size: 0.5rem; }

        .stretch-slider {
            width: 50px;
            height: 3px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .stretch-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #a29bfe;
            border-radius: 50%;
        }

        .autotune-btn, .autorhythm-btn {
            padding: 3px 6px;
            border: none;
            border-radius: 5px;
            font-size: 0.5rem;
            cursor: pointer;
            color: white;
        }

        .autotune-btn { background: linear-gradient(135deg, #fd79a8, #e84393); }
        .autorhythm-btn { background: linear-gradient(135deg, #0984e3, #74b9ff); }
        .autotune-btn.active, .autorhythm-btn.active { box-shadow: 0 0 8px currentColor; }

        .curve-select {
            padding: 2px 4px;
            border: none;
            border-radius: 3px;
            font-size: 0.5rem;
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.5);
            text-align: center;
        }

        .empty-state-icon { font-size: 2.5rem; margin-bottom: 8px; }

        .swipe-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.4);
            font-size: 0.5rem;
        }

        .master-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(30,30,50,0.98), rgba(20,20,40,0.98));
            border-top: 2px solid rgba(162,155,254,0.5);
            padding: 8px;
            z-index: 150;
            display: none;
        }

        .master-panel.visible { display: block; }

        .master-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .master-title { color: white; font-size: 0.7rem; font-weight: bold; }
        .master-buttons { display: flex; gap: 4px; }

        .master-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 5px;
            font-size: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            color: white;
        }

        .master-play-btn { background: linear-gradient(135deg, #00b894, #55efc4); }
        .master-download-btn { background: linear-gradient(135deg, #f39c12, #e74c3c); }
        .master-clear-btn { background: linear-gradient(135deg, #636e72, #b2bec3); }

        .master-timeline {
            background: rgba(0,0,0,0.4);
            border-radius: 6px;
            padding: 6px;
            min-height: 60px;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .master-timeline-inner {
            display: flex;
            gap: 4px;
            min-height: 48px;
            align-items: center;
            padding: 4px;
        }

        .master-clip {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            border-radius: 4px;
            padding: 4px 8px;
            min-width: 60px;
            position: relative;
            cursor: grab;
            display: flex;
            flex-direction: column;
            gap: 2px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .master-clip:active { cursor: grabbing; }
        .master-clip.selected { border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        .master-clip.dragging { opacity: 0.6; transform: scale(0.95); }
        .master-clip-name { color: white; font-size: 0.5rem; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .master-clip-duration { color: rgba(255,255,255,0.7); font-size: 0.4rem; }

        .master-clip-remove {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 14px;
            height: 14px;
            background: #d63031;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .crop-handles { position: absolute; bottom: 0; left: 0; right: 0; height: 8px; display: flex; justify-content: space-between; }
        .crop-handle { width: 8px; height: 100%; background: rgba(255,255,255,0.6); cursor: ew-resize; border-radius: 2px; }
        .crop-handle:hover { background: white; }
        .master-empty { color: rgba(255,255,255,0.4); font-size: 0.6rem; text-align: center; padding: 15px; }
        .license-info { color: rgba(255,255,255,0.5); font-size: 0.4rem; text-align: center; margin-top: 4px; }

        /* Remix Composer Styles */
        .remix-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 6px;
            gap: 6px;
            overflow-y: auto;
        }

        .remix-header {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .remix-card {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 8px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .remix-card-title {
            color: white;
            font-size: 0.65rem;
            font-weight: bold;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .composer-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.55rem;
            margin-bottom: 6px;
        }

        .composer-input::placeholder { color: rgba(255,255,255,0.4); }

        .remix-tracks-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin-bottom: 6px;
        }

        .remix-track-slot {
            background: rgba(0,0,0,0.3);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 6px;
            padding: 6px;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .remix-track-slot.filled {
            border-style: solid;
            border-color: rgba(162,155,254,0.5);
            background: rgba(108,92,231,0.2);
        }

        .remix-track-slot.drag-over {
            border-color: #a29bfe;
            background: rgba(162,155,254,0.3);
        }

        .remix-slot-label { color: rgba(255,255,255,0.5); font-size: 0.5rem; }
        .remix-slot-name { color: white; font-size: 0.5rem; font-weight: bold; margin-top: 2px; }
        .remix-slot-remove { font-size: 0.4rem; color: #ff7675; cursor: pointer; margin-top: 2px; }

        .warp-section {
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 6px;
            margin-bottom: 6px;
        }

        .warp-title {
            color: rgba(255,255,255,0.8);
            font-size: 0.55rem;
            margin-bottom: 4px;
            font-weight: bold;
        }

        .warp-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
        }

        .warp-checkbox {
            display: flex;
            align-items: center;
            gap: 3px;
            color: rgba(255,255,255,0.7);
            font-size: 0.45rem;
            cursor: pointer;
        }

        .warp-checkbox input {
            width: 12px;
            height: 12px;
            accent-color: #a29bfe;
        }

        .warp-checkbox.active { color: #a29bfe; font-weight: bold; }

        .license-section {
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 6px;
            margin-bottom: 6px;
        }

        .license-options {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
        }

        .license-option {
            flex: 1;
            padding: 6px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .license-option.selected {
            border-color: #a29bfe;
            background: rgba(162,155,254,0.2);
        }

        .license-option-title { color: white; font-size: 0.55rem; font-weight: bold; }
        .license-option-desc { color: rgba(255,255,255,0.6); font-size: 0.4rem; margin-top: 2px; }

        .copyright-input {
            width: 100%;
            padding: 5px 8px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.5rem;
            display: none;
        }

        .copyright-input.visible { display: block; }
        .copyright-input::placeholder { color: rgba(255,255,255,0.4); }

        .remix-export-btns {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .remix-export-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 0.55rem;
            font-weight: bold;
            cursor: pointer;
            color: white;
            flex: 1;
        }

        .remix-play-btn { background: linear-gradient(135deg, #00b894, #55efc4); }
        .remix-download-btn { background: linear-gradient(135deg, #f39c12, #e74c3c); }
        .remix-clear-btn { background: linear-gradient(135deg, #636e72, #b2bec3); }

        .intensity-slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 4px;
        }

        .intensity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #a29bfe, #6c5ce7);
            border-radius: 50%;
        }

        .intensity-label {
            color: rgba(255,255,255,0.6);
            font-size: 0.4rem;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="drumkit-container">
            <button class="drum-btn drum-0" data-drum="0">üê±</button>
            <button class="drum-btn drum-1" data-drum="1">ü¶ä</button>
            <button class="drum-btn drum-2" data-drum="2">üê∏</button>
            <button class="drum-btn drum-3" data-drum="3">ü¶ã</button>
            <button class="drum-btn drum-4" data-drum="4">üçÑ</button>
            <button class="drum-btn drum-5" data-drum="5">üå∏</button>
            <button class="drum-btn drum-6" data-drum="6">üîÆ</button>
            <button class="drum-btn drum-7" data-drum="7">üßÅ</button>
            <button class="drum-btn drum-8" data-drum="8">ü´ß</button>
            <button class="drum-btn drum-9" data-drum="9">‚ú®</button>
            <button class="ctrl-btn record-btn" id="recordBtn" title="Record">‚è∫</button>
            <button class="ctrl-btn stop-btn" id="stopBtn" title="Stop">‚èπ</button>
            <button class="ctrl-btn export-btn" id="exportBtn" title="Export">üíæ</button>
            <button class="ctrl-btn autobeat-btn" id="autoBeatBtn" title="Auto-Lock Beat">üéØ</button>
            <button class="ctrl-btn autotune-btn-top" id="autoTuneBtn" title="Auto-Tune">üéµ</button>
        </div>

        <div class="record-indicator" id="recordIndicator">‚óè REC</div>

        <div class="scene-container" id="sceneContainer">
            <!-- Scene 1: Rainbow Meadow -->
            <div class="scene scene-1" data-scene="0">
                <div class="floating-element" style="top: 1%; left: 8%;">ü¶Ñ</div>
                <div class="floating-element" style="top: 3%; right: 12%; animation-delay: 0.5s;">üê∞</div>
                <div class="header">
                    <div class="scene-title">üåà Rainbow Meadow üå∏</div>
                    <div class="scene-subtitle">X: Tone | Y: Pitch</div>
                </div>
                <div class="controls">
                    <button class="mode-btn beat-btn" data-beat="0">Hop</button>
                    <button class="mode-btn beat-btn" data-beat="1">Skip</button>
                    <button class="mode-btn beat-btn" data-beat="2">Bounce</button>
                    <button class="mode-btn beat-btn" data-beat="3">Flutter</button>
                    <button class="mode-btn beat-btn" data-beat="4">Gallop</button>
                </div>
                <div class="controls">
                    <button class="mode-btn melody-btn" data-melody="0">Sparkle</button>
                    <button class="mode-btn melody-btn" data-melody="1">Dream</button>
                    <button class="mode-btn melody-btn" data-melody="2">Magic</button>
                    <button class="mode-btn melody-btn" data-melody="3">Wish</button>
                    <button class="mode-btn melody-btn" data-melody="4">Glow</button>
                </div>
                <div class="touch-pad" data-scene-index="0">
                    <div class="xy-label pitch">‚Üë HIGH</div>
                    <div class="xy-label pitch-low">‚Üì LOW</div>
                    <div class="xy-label tone">WARM</div>
                    <div class="xy-label tone-bright">BRIGHT</div>
                    <div class="active-modes-display"></div>
                </div>
                <div class="layer-display">
                    <div class="layer-indicator" style="background: #ff6b6b;">üéµ</div>
                    <div class="layer-indicator" style="background: #feca57;">üé∂</div>
                    <div class="layer-indicator" style="background: #48dbfb;">‚ú®</div>
                    <div class="layer-indicator" style="background: #ff9ff3;">üí´</div>
                    <div class="layer-indicator" style="background: #a55eea;">üåü</div>
                </div>
            </div>

            <!-- Scene 2: Crystal Cave -->
            <div class="scene scene-2" data-scene="1">
                <div class="floating-element" style="top: 1%; left: 10%;">üíé</div>
                <div class="floating-element" style="top: 3%; right: 15%; animation-delay: 0.7s;">üîÆ</div>
                <div class="header">
                    <div class="scene-title">üíé Crystal Cave üîÆ</div>
                    <div class="scene-subtitle">X: Resonance | Y: Frequency</div>
                </div>
                <div class="controls">
                    <button class="mode-btn beat-btn" data-beat="0">Echo</button>
                    <button class="mode-btn beat-btn" data-beat="1">Pulse</button>
                    <button class="mode-btn beat-btn" data-beat="2">Crystal</button>
                    <button class="mode-btn beat-btn" data-beat="3">Cave</button>
                    <button class="mode-btn beat-btn" data-beat="4">Deep</button>
                </div>
                <div class="controls">
                    <button class="mode-btn melody-btn" data-melody="0">Mystic</button>
                    <button class="mode-btn melody-btn" data-melody="1">Aura</button>
                    <button class="mode-btn melody-btn" data-melody="2">Spirit</button>
                    <button class="mode-btn melody-btn" data-melody="3">Ethereal</button>
                    <button class="mode-btn melody-btn" data-melody="4">Cosmic</button>
                </div>
                <div class="touch-pad" data-scene-index="1">
                    <div class="xy-label pitch">‚Üë HIGH</div>
                    <div class="xy-label pitch-low">‚Üì LOW</div>
                    <div class="xy-label tone">DEEP</div>
                    <div class="xy-label tone-bright">CRYSTAL</div>
                    <div class="active-modes-display"></div>
                </div>
                <div class="layer-display">
                    <div class="layer-indicator" style="background: #a55eea;">üéπ</div>
                    <div class="layer-indicator" style="background: #5f27cd;">üé∏</div>
                    <div class="layer-indicator" style="background: #341f97;">üé∫</div>
                    <div class="layer-indicator" style="background: #48dbfb;">üéª</div>
                    <div class="layer-indicator" style="background: #0abde3;">ü™à</div>
                </div>
            </div>

            <!-- Scene 3: Cloud Kingdom -->
            <div class="scene scene-3" data-scene="2">
                <div class="floating-element" style="top: 1%; left: 8%;">‚òÅÔ∏è</div>
                <div class="floating-element" style="top: 3%; right: 12%; animation-delay: 0.3s;">‚≠ê</div>
                <div class="header">
                    <div class="scene-title">‚òÅÔ∏è Cloud Kingdom üåô</div>
                    <div class="scene-subtitle">X: Softness | Y: Dreaminess</div>
                </div>
                <div class="controls">
                    <button class="mode-btn beat-btn" data-beat="0">Float</button>
                    <button class="mode-btn beat-btn" data-beat="1">Drift</button>
                    <button class="mode-btn beat-btn" data-beat="2">Breeze</button>
                    <button class="mode-btn beat-btn" data-beat="3">Whisper</button>
                    <button class="mode-btn beat-btn" data-beat="4">Lullaby</button>
                </div>
                <div class="controls">
                    <button class="mode-btn melody-btn" data-melody="0">Sleepy</button>
                    <button class="mode-btn melody-btn" data-melody="1">Dreamy</button>
                    <button class="mode-btn melody-btn" data-melody="2">Fluffy</button>
                    <button class="mode-btn melody-btn" data-melody="3">Soft</button>
                    <button class="mode-btn melody-btn" data-melody="4">Gentle</button>
                </div>
                <div class="touch-pad" data-scene-index="2">
                    <div class="xy-label pitch">‚Üë AIRY</div>
                    <div class="xy-label pitch-low">‚Üì COZY</div>
                    <div class="xy-label tone">SOFT</div>
                    <div class="xy-label tone-bright">SHIMMER</div>
                    <div class="active-modes-display"></div>
                </div>
                <div class="layer-display">
                    <div class="layer-indicator" style="background: #74b9ff;">üå∏</div>
                    <div class="layer-indicator" style="background: #a29bfe;">ü¶ã</div>
                    <div class="layer-indicator" style="background: #fd79a8;">üå∫</div>
                    <div class="layer-indicator" style="background: #fdcb6e;">üåª</div>
                    <div class="layer-indicator" style="background: #81ecec;">üçÄ</div>
                </div>
            </div>

            <!-- Scene 4: Mixer Studio -->
            <div class="scene scene-4" data-scene="3">
                <div class="header">
                    <div class="scene-title">üéõÔ∏è Mixer Studio üéöÔ∏è</div>
                    <div class="scene-subtitle">Import, Mix & Master</div>
                </div>
                <div class="mixer-container">
                    <div class="mixer-header">
                        <button class="mixer-btn import-btn" id="importBtn">üì• Import</button>
                        <button class="mixer-btn play-all-btn" id="playAllBtn">‚ñ∂Ô∏è Play</button>
                        <button class="mixer-btn stop-all-btn" id="stopAllBtn">‚èπ Stop</button>
                        <button class="mixer-btn clear-btn" id="clearAllBtn">üóëÔ∏è Clear</button>
                    </div>
                    <div class="tracks-container" id="tracksContainer">
                        <div class="empty-state" id="emptyState">
                            <div class="empty-state-icon">üéµ</div>
                            <div style="font-size: 0.7rem;">No tracks yet!</div>
                            <div style="font-size: 0.55rem; margin-top: 4px;">Record or import JSON</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Scene 5: Remix Composer -->
            <div class="scene scene-5" data-scene="4">
                <div class="header">
                    <div class="scene-title">üé® Remix Composer üîÑ</div>
                    <div class="scene-subtitle">Import Masters & Apply Warps</div>
                </div>
                <div class="remix-container">
                    <div class="remix-card">
                        <div class="remix-card-title">üë§ Composer Info</div>
                        <input type="text" class="composer-input" id="composerName" placeholder="Enter composer/artist name...">
                        <input type="text" class="composer-input" id="remixTitle" placeholder="Remix title...">
                    </div>

                    <div class="remix-card">
                        <div class="remix-card-title">üì• Import Masters (Up to 4)</div>
                        <div class="remix-header" style="margin-bottom: 6px;">
                            <button class="mixer-btn import-btn" id="remixImportBtn">üì• Import Master</button>
                        </div>
                        <div class="remix-tracks-grid" id="remixTracksGrid">
                            <div class="remix-track-slot" data-slot="0"><span class="remix-slot-label">Track 1</span></div>
                            <div class="remix-track-slot" data-slot="1"><span class="remix-slot-label">Track 2</span></div>
                            <div class="remix-track-slot" data-slot="2"><span class="remix-slot-label">Track 3</span></div>
                            <div class="remix-track-slot" data-slot="3"><span class="remix-slot-label">Track 4</span></div>
                        </div>
                    </div>

                    <div class="remix-card">
                        <div class="remix-card-title">üåÄ Sequence Warps</div>
                        <div class="warp-section">
                            <div class="warp-title">Mathematical Sequences</div>
                            <div class="warp-grid">
                                <label class="warp-checkbox"><input type="checkbox" data-warp="fibonacci"> Fibonacci</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="lucas"> Lucas</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="catalan"> Catalan</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="pell"> Pell</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="bell"> Bell</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="triangular"> Triangular</label>
                            </div>
                        </div>
                        <div class="warp-section">
                            <div class="warp-title">Time Warps</div>
                            <div class="warp-grid">
                                <label class="warp-checkbox"><input type="checkbox" data-warp="linear"> Linear</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="log"> Logarithmic</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="exp"> Exponential</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="sine"> Sine Wave</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="bounce"> Bounce</label>
                                <label class="warp-checkbox"><input type="checkbox" data-warp="elastic"> Elastic</label>
                            </div>
                        </div>
                        <div class="intensity-label"><span>Intensity</span><span id="intensityValue">50%</span></div>
                        <input type="range" class="intensity-slider" id="warpIntensity" min="0" max="100" value="50">
                    </div>

                    <div class="remix-card">
                        <div class="remix-card-title">üìú License</div>
                        <div class="license-section">
                            <div class="license-options">
                                <div class="license-option selected" data-license="cc0">
                                    <div class="license-option-title">CC0</div>
                                    <div class="license-option-desc">Public Domain</div>
                                </div>
                                <div class="license-option" data-license="mit">
                                    <div class="license-option-title">MIT</div>
                                    <div class="license-option-desc">With Copyright</div>
                                </div>
                            </div>
                            <input type="text" class="copyright-input" id="copyrightHolder" placeholder="Copyright holder name (for MIT)...">
                        </div>
                    </div>

                    <div class="remix-export-btns">
                        <button class="remix-export-btn remix-play-btn" id="remixPlayBtn">‚ñ∂Ô∏è Preview</button>
                        <button class="remix-export-btn remix-download-btn" id="remixDownloadBtn">üíæ Export</button>
                        <button class="remix-export-btn remix-clear-btn" id="remixClearBtn">üóëÔ∏è Clear</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Master Channel Panel -->
        <div class="master-panel" id="masterPanel">
            <div class="master-header">
                <div class="master-title">üéπ Master Channel ‚ú®</div>
                <div class="master-buttons">
                    <button class="master-btn master-play-btn" id="masterPlayBtn">‚ñ∂Ô∏è Play</button>
                    <button class="master-btn master-download-btn" id="masterDownloadBtn">üíæ CC0</button>
                    <button class="master-btn master-clear-btn" id="masterClearBtn">üóëÔ∏è</button>
                </div>
            </div>
            <div class="master-timeline" id="masterTimeline">
                <div class="master-timeline-inner" id="masterTimelineInner">
                    <div class="master-empty" id="masterEmpty">Drag tracks here or tap ‚ûï to add clips üéµ</div>
                </div>
            </div>
            <div class="license-info">üìú CC0 1.0 Universal - Public Domain Dedication</div>
        </div>

        <div class="scene-dots">
            <div class="dot active" data-scene="0"></div>
            <div class="dot" data-scene="1"></div>
            <div class="dot" data-scene="2"></div>
            <div class="dot" data-scene="3"></div>
            <div class="dot" data-scene="4"></div>
        </div>
        
        <div class="swipe-hint">‚Üê Swipe to change scenes ‚Üí</div>
    </div>

    <input type="file" id="fileInput" accept=".json" multiple style="display:none;">
    <input type="file" id="remixFileInput" accept=".json" multiple style="display:none;">

    <script>
        const BPM = 120;
        const STEP_DURATION = (60000 / BPM) / 4;
        const STEPS_PER_BAR = 16;
        const TOTAL_STEPS = 64;
        const MAX_HARMONY_CHANNELS = 5;
        
        let audioContext, masterGain;
        let isRecording = false, recordingStartTime = 0;
        let autoBeatLock = false, autoTuneLock = false;
        let currentRecording = null;
        let activeSustainedNotes = new Map();
        let isPlaying = false, playbackTimeouts = [];
        let mixerTracks = [];
        let masterClips = [], selectedClipIndex = -1;
        let currentScene = 0;
        let draggedTrackIndex = null, draggedClipIndex = null;
        
        // Remix state
        let remixTracks = [null, null, null, null];
        let selectedLicense = 'cc0';
        let activeWarps = new Set();
        let warpIntensity = 50;

        const sceneSettings = [
            { beatModes: new Set(), melodyModes: new Set() },
            { beatModes: new Set(), melodyModes: new Set() },
            { beatModes: new Set(), melodyModes: new Set() }
        ];
        
        const beatLoops = [
            { intervals: [], active: false },
            { intervals: [], active: false },
            { intervals: [], active: false }
        ];
        
        const drumSounds = [
            { emoji: 'üê±', freq: 180, type: 'sine', decay: 0.3, pitch: 1.5 },
            { emoji: 'ü¶ä', freq: 120, type: 'triangle', decay: 0.25, pitch: 0.8 },
            { emoji: 'üê∏', freq: 80, type: 'square', decay: 0.15, pitch: 2 },
            { emoji: 'ü¶ã', freq: 800, type: 'sine', decay: 0.5, pitch: 1.2 },
            { emoji: 'üçÑ', freq: 60, type: 'sawtooth', decay: 0.4, pitch: 0.5 },
            { emoji: 'üå∏', freq: 600, type: 'sine', decay: 0.6, pitch: 1.8 },
            { emoji: 'üîÆ', freq: 400, type: 'triangle', decay: 0.7, pitch: 0.7 },
            { emoji: 'üßÅ', freq: 300, type: 'sine', decay: 0.2, pitch: 1.3 },
            { emoji: 'ü´ß', freq: 1200, type: 'sine', decay: 0.4, pitch: 2.5 },
            { emoji: '‚ú®', freq: 2000, type: 'sine', decay: 0.3, pitch: 3 }
        ];
        
        const melodyScales = [
            [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25],
            [293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33],
            [329.63, 369.99, 415.30, 466.16, 523.25, 587.33, 659.25, 739.99],
            [349.23, 392.00, 440.00, 466.16, 523.25, 587.33, 622.25, 698.46],
            [392.00, 440.00, 493.88, 523.25, 587.33, 659.25, 698.46, 783.99]
        ];
        
        const beatPatterns = [
            { intervals: [250, 250, 250, 250], accents: [1, 0.5, 0.7, 0.5] },
            { intervals: [200, 400, 200, 400], accents: [1, 0.3, 0.8, 0.4] },
            { intervals: [150, 150, 300, 150, 150], accents: [1, 0.6, 0.4, 0.8, 0.5] },
            { intervals: [300, 150, 150, 300], accents: [0.8, 0.5, 0.5, 1] },
            { intervals: [400, 200, 200, 400, 200], accents: [1, 0.4, 0.6, 0.8, 0.3] }
        ];
        
        const layerColors = [
            ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#a55eea'],
            ['#a55eea', '#5f27cd', '#341f97', '#48dbfb', '#0abde3'],
            ['#74b9ff', '#a29bfe', '#fd79a8', '#fdcb6e', '#81ecec']
        ];
        
        const synthConfigs = [
            { types: ['sine', 'triangle', 'sine', 'triangle', 'sine'], filterBase: 2000 },
            { types: ['sawtooth', 'square', 'triangle', 'sine', 'sawtooth'], filterBase: 1500 },
            { types: ['sine', 'sine', 'triangle', 'sine', 'triangle'], filterBase: 3000 }
        ];

        // Mathematical Sequences
        const sequences = {
            fibonacci: (n) => { let a = 0, b = 1; for (let i = 0; i < n; i++) { [a, b] = [b, a + b]; } return a; },
            lucas: (n) => { let a = 2, b = 1; for (let i = 0; i < n; i++) { [a, b] = [b, a + b]; } return a; },
            catalan: (n) => { if (n <= 1) return 1; let c = 0; for (let i = 0; i < n; i++) c += sequences.catalan(i) * sequences.catalan(n - 1 - i); return c; },
            pell: (n) => { let a = 0, b = 1; for (let i = 0; i < n; i++) { [a, b] = [b, 2 * b + a]; } return a; },
            bell: (n) => { const b = [[1]]; for (let i = 1; i <= n; i++) { b[i] = [b[i-1][b[i-1].length-1]]; for (let j = 1; j <= i; j++) b[i].push(b[i][j-1] + b[i-1][j-1]); } return b[n][0]; },
            triangular: (n) => (n * (n + 1)) / 2
        };

        function generateSequenceValues(type, count) {
            const values = [];
            for (let i = 0; i < count; i++) {
                values.push(sequences[type](i % 12));
            }
            const max = Math.max(...values);
            return values.map(v => v / max);
        }

        function applySequenceWarp(step, totalSteps, activeWarps, intensity) {
            if (activeWarps.size === 0) return step;
            
            const t = step / totalSteps;
            let warpedT = t;
            const intensityFactor = intensity / 100;
            
            activeWarps.forEach(warpType => {
                let warpValue = 0;
                const seqIndex = Math.floor(t * 12);
                
                switch(warpType) {
                    case 'fibonacci': warpValue = (sequences.fibonacci(seqIndex) % 10) / 10; break;
                    case 'lucas': warpValue = (sequences.lucas(seqIndex) % 10) / 10; break;
                    case 'catalan': warpValue = Math.min(1, sequences.catalan(Math.min(seqIndex, 8)) / 100); break;
                    case 'pell': warpValue = (sequences.pell(seqIndex) % 20) / 20; break;
                    case 'bell': warpValue = Math.min(1, sequences.bell(Math.min(seqIndex, 8)) / 100); break;
                    case 'triangular': warpValue = sequences.triangular(seqIndex) / sequences.triangular(12); break;
                    case 'linear': warpValue = t; break;
                    case 'log': warpValue = Math.log(1 + t * 9) / Math.log(10); break;
                    case 'exp': warpValue = (Math.pow(10, t) - 1) / 9; break;
                    case 'sine': warpValue = (Math.sin(t * Math.PI * 2) + 1) / 2; break;
                    case 'bounce': warpValue = Math.abs(Math.sin(t * Math.PI * 3)); break;
                    case 'elastic': warpValue = Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1; break;
                }
                
                warpedT = warpedT * (1 - intensityFactor * 0.5) + warpValue * intensityFactor * 0.5;
            });
            
            return Math.max(0, Math.min(totalSteps, warpedT * totalSteps));
        }

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.25;
                masterGain.connect(audioContext.destination);
            }
            if (audioContext.state === 'suspended') audioContext.resume();
        }

        function getRecordingTime() { return Date.now() - recordingStartTime; }
        function timeToStep(time) { return time / STEP_DURATION; }
        function stepToTime(step) { return step * STEP_DURATION; }

        function quantizeToScale(freq, scaleIndex = 0) {
            const scale = melodyScales[scaleIndex];
            return scale.reduce((closest, note) => Math.abs(freq - note) < Math.abs(freq - closest) ? note : closest, scale[0]);
        }

        function createNewRecording() {
            return {
                version: "3.0",
                name: `Recording ${new Date().toLocaleTimeString()}`,
                bpm: BPM, stepsPerBar: STEPS_PER_BAR, totalSteps: TOTAL_STEPS,
                duration: 0, autoBeat: autoBeatLock, autoTune: autoTuneLock,
                channels: { beats: { type: "beats", events: [] }, harmony: [] }
            };
        }

        function recordDrumHit(drumIndex) {
            if (!isRecording || !currentRecording) return;
            let step = timeToStep(getRecordingTime());
            if (autoBeatLock) step = Math.round(step);
            if (step < TOTAL_STEPS) currentRecording.channels.beats.events.push({ step, drumIndex });
        }

        function getOrCreateHarmonyChannel(channelIndex, sceneIndex) {
            if (!currentRecording) return null;
            let channel = currentRecording.channels.harmony.find(c => c.channelIndex === channelIndex && c.sceneIndex === sceneIndex);
            if (!channel) { channel = { channelIndex, sceneIndex, notes: [] }; currentRecording.channels.harmony.push(channel); }
            return channel;
        }

        function startPadRecording(sceneIndex, fingerIndex, x, y, normX, normY) {
            if (!isRecording || !currentRecording) return null;
            let step = timeToStep(getRecordingTime());
            if (autoBeatLock) step = Math.round(step);
            let freq = calculateFrequency(sceneIndex, normY);
            if (autoTuneLock) freq = quantizeToScale(freq, 0);
            const filter = calculateFilter(sceneIndex, normX);
            const channel = getOrCreateHarmonyChannel(fingerIndex, sceneIndex);
            if (!channel) return null;
            const noteData = { startStep: step, endStep: null, events: [{ step, x: normX, y: normY, freq, filter }] };
            channel.notes.push(noteData);
            return { channelIndex: fingerIndex, sceneIndex, noteIndex: channel.notes.length - 1 };
        }

        function updatePadRecording(recordRef, normX, normY, sceneIndex) {
            if (!isRecording || !currentRecording || !recordRef) return;
            const channel = currentRecording.channels.harmony.find(c => c.channelIndex === recordRef.channelIndex && c.sceneIndex === recordRef.sceneIndex);
            if (!channel) return;
            const noteData = channel.notes[recordRef.noteIndex];
            if (!noteData) return;
            let step = timeToStep(getRecordingTime());
            if (autoBeatLock) step = Math.round(step);
            const lastEvent = noteData.events[noteData.events.length - 1];
            if (step > lastEvent.step && step < TOTAL_STEPS) {
                let freq = calculateFrequency(sceneIndex, normY);
                if (autoTuneLock) freq = quantizeToScale(freq, 0);
                noteData.events.push({ step, x: normX, y: normY, freq, filter: calculateFilter(sceneIndex, normX) });
            }
        }

        function endPadRecording(recordRef) {
            if (!isRecording || !currentRecording || !recordRef) return;
            const channel = currentRecording.channels.harmony.find(c => c.channelIndex === recordRef.channelIndex && c.sceneIndex === recordRef.sceneIndex);
            if (!channel) return;
            const noteData = channel.notes[recordRef.noteIndex];
            if (!noteData) return;
            let step = timeToStep(getRecordingTime());
            if (autoBeatLock) step = Math.round(step);
            noteData.endStep = step;
        }

        function calculateFrequency(sceneIndex, normY) {
            const settings = sceneSettings[sceneIndex];
            const activeMelodies = Array.from(settings.melodyModes);
            if (activeMelodies.length === 0) return 440;
            const scale = melodyScales[activeMelodies[0]];
            return scale[Math.floor(normY * (scale.length - 1))];
        }

        function calculateFilter(sceneIndex, normX) {
            return synthConfigs[sceneIndex].filterBase + (normX * 4000);
        }

        function startRecording() {
            isRecording = true;
            recordingStartTime = Date.now();
            currentRecording = createNewRecording();
            document.getElementById('recordBtn').classList.add('recording');
            document.getElementById('recordIndicator').classList.add('visible');
            setTimeout(() => { if (isRecording) stopRecording(); }, TOTAL_STEPS * STEP_DURATION);
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            if (currentRecording) {
                currentRecording.duration = getRecordingTime();
                const hasContent = currentRecording.channels.beats.events.length > 0 || currentRecording.channels.harmony.some(c => c.notes.length > 0);
                if (hasContent) { mixerTracks.push(currentRecording); renderTracks(); updateMasterPanelVisibility(); }
            }
            document.getElementById('recordBtn').classList.remove('recording');
            document.getElementById('recordIndicator').classList.remove('visible');
        }

        function stopAllPlayback() {
            playbackTimeouts.forEach(id => clearTimeout(id));
            playbackTimeouts = [];
            isPlaying = false;
            activeSustainedNotes.forEach(noteData => {
                if (noteData.gainNode) noteData.gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.05);
                if (noteData.oscillator) setTimeout(() => { try { noteData.oscillator.stop(); } catch(e) {} }, 100);
            });
            activeSustainedNotes.clear();
            [0, 1, 2].forEach(i => stopBeatLoops(i));
        }

        function downloadJson(json, prefix) {
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${prefix}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportRecording() {
            if (mixerTracks.length > 0) {
                const exportData = { version: "3.0", tracks: mixerTracks };
                downloadJson(JSON.stringify(exportData, null, 2), 'fluffcore-mix');
            } else { alert('Nothing to export!'); }
        }

        document.getElementById('autoBeatBtn').addEventListener('click', (e) => {
            e.preventDefault(); autoBeatLock = !autoBeatLock; e.target.classList.toggle('active', autoBeatLock);
        });

        document.getElementById('autoTuneBtn').addEventListener('click', (e) => {
            e.preventDefault(); autoTuneLock = !autoTuneLock; e.target.classList.toggle('active', autoTuneLock);
        });

        document.getElementById('recordBtn').addEventListener('click', (e) => {
            e.preventDefault(); initAudio(); isRecording ? stopRecording() : startRecording();
        });

        document.getElementById('stopBtn').addEventListener('click', (e) => { e.preventDefault(); stopRecording(); stopAllPlayback(); });
        document.getElementById('exportBtn').addEventListener('click', (e) => { e.preventDefault(); exportRecording(); });

        function playDrumSound(drumIndex, shouldRecord = true) {
            if (!audioContext) return;
            const drum = drumSounds[drumIndex];
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            osc.type = drum.type;
            osc.frequency.setValueAtTime(drum.freq * drum.pitch, now);
            osc.frequency.exponentialRampToValueAtTime(drum.freq * 0.3, now + drum.decay);
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(3000, now);
            filter.frequency.exponentialRampToValueAtTime(500, now + drum.decay);
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + drum.decay);
            osc.connect(filter); filter.connect(gain); gain.connect(masterGain);
            osc.start(now); osc.stop(now + drum.decay + 0.1);
            if (shouldRecord) recordDrumHit(drumIndex);
        }

        document.querySelectorAll('.drum-btn').forEach(btn => {
            const trigger = (e) => {
                e.preventDefault(); initAudio();
                playDrumSound(parseInt(btn.dataset.drum));
                btn.classList.add('playing'); setTimeout(() => btn.classList.remove('playing'), 150);
            };
            btn.addEventListener('touchstart', trigger);
            btn.addEventListener('mousedown', trigger);
        });

        function createContinuousTone(sceneIndex, layerIndex, x, y, padWidth, padHeight) {
            if (!audioContext) return null;
            const settings = sceneSettings[sceneIndex];
            const activeMelodies = Array.from(settings.melodyModes);
            if (activeMelodies.length === 0) return null;
            const config = synthConfigs[sceneIndex];
            const oscillators = [], gainNodes = [], filters = [];
            const normX = Math.max(0, Math.min(1, x / padWidth));
            const normY = Math.max(0, Math.min(1, 1 - (y / padHeight)));
            activeMelodies.forEach((melodyMode) => {
                const scale = melodyScales[melodyMode];
                let freq = scale[Math.floor(normY * (scale.length - 1))] * (1 + (layerIndex * 0.01));
                if (autoTuneLock) freq = quantizeToScale(freq, melodyMode);
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                oscillator.type = config.types[layerIndex % 5];
                oscillator.frequency.value = freq;
                filter.type = 'lowpass';
                filter.frequency.value = config.filterBase + (normX * 4000);
                filter.Q.value = 2 + (normX * 8);
                gainNode.gain.value = 0.15 / Math.max(1, activeMelodies.length);
                oscillator.connect(filter); filter.connect(gainNode); gainNode.connect(masterGain);
                oscillator.start();
                oscillators.push(oscillator); gainNodes.push(gainNode); filters.push(filter);
            });
            return { oscillators, gainNodes, filters, sceneIndex };
        }

        function updateTonePosition(soundData, x, y, padWidth, padHeight) {
            if (!soundData) return;
            const settings = sceneSettings[soundData.sceneIndex];
            const activeMelodies = Array.from(settings.melodyModes);
            const normX = Math.max(0, Math.min(1, x / padWidth));
            const normY = Math.max(0, Math.min(1, 1 - (y / padHeight)));
            soundData.oscillators.forEach((osc, idx) => {
                const melodyMode = activeMelodies[idx];
                if (melodyMode === undefined) return;
                const scale = melodyScales[melodyMode];
                let freq = scale[Math.floor(normY * (scale.length - 1))];
                if (autoTuneLock) freq = quantizeToScale(freq, melodyMode);
                osc.frequency.setTargetAtTime(freq, audioContext.currentTime, 0.05);
            });
            soundData.filters.forEach(filter => {
                filter.frequency.setTargetAtTime(synthConfigs[soundData.sceneIndex].filterBase + (normX * 4000), audioContext.currentTime, 0.05);
            });
        }

        function stopTone(soundData) {
            if (!soundData) return;
            soundData.gainNodes.forEach(gain => gain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1));
            setTimeout(() => soundData.oscillators.forEach(osc => { try { osc.stop(); } catch(e) {} }), 300);
        }

        function createBeatSound(beatMode, sceneIndex, accent = 1) {
            if (!audioContext) return;
            const freq = [60, 80, 50, 100, 70][beatMode];
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.type = ['sine', 'triangle', 'square', 'sawtooth', 'sine'][beatMode];
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(freq * 0.4, audioContext.currentTime + 0.15);
            gainNode.gain.setValueAtTime(0.2 * accent, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            oscillator.connect(gainNode); gainNode.connect(masterGain);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.25);
        }

        function startBeatLoops(sceneIndex) {
            stopBeatLoops(sceneIndex);
            const settings = sceneSettings[sceneIndex];
            if (settings.beatModes.size === 0) return;
            settings.beatModes.forEach(beatMode => {
                const pattern = beatPatterns[beatMode];
                let stepIndex = 0;
                function playStep() {
                    if (!beatLoops[sceneIndex].active) return;
                    createBeatSound(beatMode, sceneIndex, pattern.accents[stepIndex]);
                    stepIndex = (stepIndex + 1) % pattern.intervals.length;
                    beatLoops[sceneIndex].intervals.push(setTimeout(playStep, pattern.intervals[stepIndex]));
                }
                beatLoops[sceneIndex].active = true;
                playStep();
            });
        }

        function stopBeatLoops(sceneIndex) {
            beatLoops[sceneIndex].intervals.forEach(id => clearTimeout(id));
            beatLoops[sceneIndex].intervals = [];
            beatLoops[sceneIndex].active = false;
        }

        function updateLayerIndicators(sceneIndex, count) {
            const scene = document.querySelectorAll('.scene')[sceneIndex];
            scene.querySelectorAll('.layer-indicator').forEach((ind, i) => ind.classList.toggle('active', i < count));
        }

        function updateActiveModeDisplay(sceneIndex) {
            const scene = document.querySelectorAll('.scene')[sceneIndex];
            const display = scene.querySelector('.active-modes-display');
            if (!display) return;
            const settings = sceneSettings[sceneIndex];
            display.innerHTML = '';
            const beatNames = [['Hop', 'Skip', 'Bounce', 'Flutter', 'Gallop'], ['Echo', 'Pulse', 'Crystal', 'Cave', 'Deep'], ['Float', 'Drift', 'Breeze', 'Whisper', 'Lullaby']];
            const melodyNames = [['Sparkle', 'Dream', 'Magic', 'Wish', 'Glow'], ['Mystic', 'Aura', 'Spirit', 'Ethereal', 'Cosmic'], ['Sleepy', 'Dreamy', 'Fluffy', 'Soft', 'Gentle']];
            settings.beatModes.forEach(mode => { const tag = document.createElement('div'); tag.className = 'active-mode-tag'; tag.textContent = 'ü•Å' + beatNames[sceneIndex][mode]; display.appendChild(tag); });
            settings.melodyModes.forEach(mode => { const tag = document.createElement('div'); tag.className = 'active-mode-tag'; tag.textContent = 'üéµ' + melodyNames[sceneIndex][mode]; display.appendChild(tag); });
        }

        function createTouchVisual(x, y, touchPad, layerIndex, sceneIndex) {
            const color = layerColors[sceneIndex][layerIndex % 5];
            const indicator = document.createElement('div');
            indicator.className = 'touch-indicator';
            indicator.style.cssText = `left:${x}px;top:${y}px;width:35px;height:35px;background:radial-gradient(circle,${color} 0%,transparent 70%);box-shadow:0 0 12px ${color};`;
            touchPad.appendChild(indicator);
            const ring = document.createElement('div');
            ring.className = 'touch-ring';
            ring.style.cssText = `left:${x}px;top:${y}px;width:35px;height:35px;border-color:${color};`;
            touchPad.appendChild(ring);
            return { indicator, ring };
        }

        function createSparkle(x, y, touchPad, sceneIndex) {
            const colors = layerColors[sceneIndex];
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.style.cssText = `left:${x + (Math.random()-0.5)*25}px;top:${y + (Math.random()-0.5)*25}px;background:${colors[Math.floor(Math.random()*colors.length)]};`;
            touchPad.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 500);
        }

        document.querySelectorAll('.touch-pad').forEach((pad) => {
            const sceneIndex = parseInt(pad.dataset.sceneIndex);
            const padTouches = new Map();
            let mouseData = null;

            pad.addEventListener('touchstart', (e) => {
                e.preventDefault(); initAudio();
                const rect = pad.getBoundingClientRect();
                for (let touch of e.changedTouches) {
                    const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
                    const layerIndex = padTouches.size;
                    if (layerIndex < 5) {
                        const visual = createTouchVisual(x, y, pad, layerIndex, sceneIndex);
                        const sound = createContinuousTone(sceneIndex, layerIndex, x, y, rect.width, rect.height);
                        const normX = x / rect.width, normY = 1 - (y / rect.height);
                        const recordRef = startPadRecording(sceneIndex, layerIndex, x, y, normX, normY);
                        padTouches.set(touch.identifier, { x, y, visual, sound, layerIndex, recordRef, rect });
                        createSparkle(x, y, pad, sceneIndex);
                    }
                }
                updateLayerIndicators(sceneIndex, Math.min(padTouches.size, 5));
                if (padTouches.size > 0 && !beatLoops[sceneIndex].active) startBeatLoops(sceneIndex);
            });

            pad.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    const data = padTouches.get(touch.identifier);
                    if (data) {
                        const x = touch.clientX - data.rect.left, y = touch.clientY - data.rect.top;
                        data.visual.indicator.style.left = x + 'px'; data.visual.indicator.style.top = y + 'px';
                        data.visual.ring.style.left = x + 'px'; data.visual.ring.style.top = y + 'px';
                        if (data.sound) updateTonePosition(data.sound, x, y, data.rect.width, data.rect.height);
                        updatePadRecording(data.recordRef, x / data.rect.width, 1 - (y / data.rect.height), sceneIndex);
                        if (Math.random() < 0.08) createSparkle(x, y, pad, sceneIndex);
                    }
                }
            });

            const handleTouchEnd = (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    const data = padTouches.get(touch.identifier);
                    if (data) {
                        data.visual.indicator.style.opacity = '0'; data.visual.ring.remove();
                        setTimeout(() => data.visual.indicator.remove(), 300);
                        if (data.sound) stopTone(data.sound);
                        endPadRecording(data.recordRef);
                        padTouches.delete(touch.identifier);
                    }
                }
                updateLayerIndicators(sceneIndex, padTouches.size);
                if (padTouches.size === 0) stopBeatLoops(sceneIndex);
            };
            pad.addEventListener('touchend', handleTouchEnd);
            pad.addEventListener('touchcancel', handleTouchEnd);

            pad.addEventListener('mousedown', (e) => {
                e.preventDefault(); initAudio();
                const rect = pad.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const visual = createTouchVisual(x, y, pad, 0, sceneIndex);
                const sound = createContinuousTone(sceneIndex, 0, x, y, rect.width, rect.height);
                const recordRef = startPadRecording(sceneIndex, 0, x, y, x / rect.width, 1 - (y / rect.height));
                mouseData = { x, y, visual, sound, rect, recordRef };
                updateLayerIndicators(sceneIndex, 1);
                startBeatLoops(sceneIndex);
                createSparkle(x, y, pad, sceneIndex);
            });

            pad.addEventListener('mousemove', (e) => {
                if (!mouseData) return;
                const x = e.clientX - mouseData.rect.left, y = e.clientY - mouseData.rect.top;
                mouseData.visual.indicator.style.left = x + 'px'; mouseData.visual.indicator.style.top = y + 'px';
                mouseData.visual.ring.style.left = x + 'px'; mouseData.visual.ring.style.top = y + 'px';
                if (mouseData.sound) updateTonePosition(mouseData.sound, x, y, mouseData.rect.width, mouseData.rect.height);
                updatePadRecording(mouseData.recordRef, x / mouseData.rect.width, 1 - (y / mouseData.rect.height), sceneIndex);
                if (Math.random() < 0.08) createSparkle(x, y, pad, sceneIndex);
            });

            const endMouse = () => {
                if (mouseData) {
                    mouseData.visual.indicator.remove(); mouseData.visual.ring.remove();
                    if (mouseData.sound) stopTone(mouseData.sound);
                    endPadRecording(mouseData.recordRef);
                    mouseData = null;
                    updateLayerIndicators(sceneIndex, 0);
                    stopBeatLoops(sceneIndex);
                }
            };
            pad.addEventListener('mouseup', endMouse);
            pad.addEventListener('mouseleave', endMouse);
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); initAudio();
                const sceneEl = btn.closest('.scene');
                const sceneIndex = parseInt(sceneEl.dataset.scene);
                const settings = sceneSettings[sceneIndex];
                if (btn.classList.contains('beat-btn')) {
                    const beatMode = parseInt(btn.dataset.beat);
                    if (settings.beatModes.has(beatMode)) { settings.beatModes.delete(beatMode); btn.classList.remove('active'); }
                    else { settings.beatModes.add(beatMode); btn.classList.add('active'); createBeatSound(beatMode, sceneIndex, 1); }
                    if (beatLoops[sceneIndex].active) startBeatLoops(sceneIndex);
                } else if (btn.classList.contains('melody-btn')) {
                    const melodyMode = parseInt(btn.dataset.melody);
                    if (settings.melodyModes.has(melodyMode)) { settings.melodyModes.delete(melodyMode); btn.classList.remove('active'); }
                    else { settings.melodyModes.add(melodyMode); btn.classList.add('active'); }
                }
                updateActiveModeDisplay(sceneIndex);
            });
        });

        const tracksContainer = document.getElementById('tracksContainer');
        const emptyState = document.getElementById('emptyState');
        const fileInput = document.getElementById('fileInput');

        function createChannelGrids(track) {
            let html = '<div class="channel-grid">';
            const beatSteps = new Set();
            if (track.channels?.beats) track.channels.beats.events.forEach(e => beatSteps.add(Math.floor(e.step)));
            html += '<div class="channel-row"><span class="channel-label">ü•Å</span><div class="step-grid">';
            for (let i = 0; i < Math.min(TOTAL_STEPS, 32); i++) {
                html += `<div class="step-cell${beatSteps.has(i) ? ' has-event' : ''}${i % 4 === 0 ? ' beat-marker' : ''}"></div>`;
            }
            html += '</div></div>';
            const harmonyChannels = track.channels?.harmony || [];
            for (let ch = 0; ch < Math.min(harmonyChannels.length, MAX_HARMONY_CHANNELS); ch++) {
                const channelData = harmonyChannels.find(c => c.channelIndex === ch);
                const eventSteps = new Set(), sustainSteps = new Set();
                if (channelData) {
                    channelData.notes.forEach(note => {
                        note.events.forEach(e => eventSteps.add(Math.floor(e.step)));
                        if (note.endStep !== null) for (let s = Math.floor(note.startStep); s <= Math.floor(note.endStep); s++) sustainSteps.add(s);
                    });
                }
                const emojis = ['üéµ', 'üé∂', '‚ú®', 'üí´', 'üåü'];
                html += `<div class="channel-row"><span class="channel-label">${emojis[ch]}</span><div class="step-grid">`;
                for (let i = 0; i < Math.min(TOTAL_STEPS, 32); i++) {
                    html += `<div class="step-cell${eventSteps.has(i) ? ' has-event' : ''}${sustainSteps.has(i) && !eventSteps.has(i) ? ' has-sustain' : ''}${i % 4 === 0 ? ' beat-marker' : ''}"></div>`;
                }
                html += '</div></div>';
            }
            html += '</div>';
            return html;
        }

        function renderTracks() {
            tracksContainer.innerHTML = '';
            if (mixerTracks.length === 0) { tracksContainer.appendChild(emptyState); }
            else { mixerTracks.forEach((track, index) => tracksContainer.appendChild(createTrackElement(track, index))); }
            attachTrackListeners();
        }

        function createTrackElement(track, index) {
            const trackEl = document.createElement('div');
            trackEl.className = 'track-item';
            trackEl.draggable = true;
            trackEl.dataset.trackIndex = index;
            const beatCount = track.channels?.beats?.events?.length || 0;
            const harmonyCount = track.channels?.harmony?.reduce((sum, ch) => sum + ch.notes.length, 0) || 0;
            trackEl.innerHTML = `
                <div class="track-header">
                    <div><span class="track-name">${track.name || 'Track ' + (index + 1)}</span><div class="track-info">${beatCount} beats, ${harmonyCount} notes</div></div>
                    <div class="track-controls">
                        <button class="track-btn track-add-master" data-index="${index}" title="Add to Master">‚ûï</button>
                        <button class="track-btn track-play" data-index="${index}">‚ñ∂</button>
                        <button class="track-btn track-delete" data-index="${index}">‚úï</button>
                    </div>
                </div>
                ${createChannelGrids(track)}
            `;
            return trackEl;
        }

        function attachTrackListeners() {
            document.querySelectorAll('.track-play').forEach(btn => btn.addEventListener('click', () => playTrack(mixerTracks[parseInt(btn.dataset.index)])));
            document.querySelectorAll('.track-delete').forEach(btn => btn.addEventListener('click', () => { mixerTracks.splice(parseInt(btn.dataset.index), 1); renderTracks(); updateMasterPanelVisibility(); }));
            document.querySelectorAll('.track-add-master').forEach(btn => btn.addEventListener('click', () => addTrackToMaster(parseInt(btn.dataset.index))));
        }

        function createSustainedNote(freq, filterValue, sceneIndex = 0) {
            const config = synthConfigs[sceneIndex];
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            oscillator.type = config.types[0];
            oscillator.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = filterValue || 2000;
            filter.Q.value = 2;
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.12, audioContext.currentTime + 0.02);
            oscillator.connect(filter); filter.connect(gainNode); gainNode.connect(masterGain);
            oscillator.start();
            return { oscillator, gainNode, filter };
        }

        function playTrack(track, timeOffset = 0, warpSettings = null) {
            initAudio();
            const totalSteps = track.totalSteps || TOTAL_STEPS;
            const cropStart = track.cropStart || 0;
            const cropEnd = track.cropEnd || totalSteps;
            const warps = warpSettings?.warps || new Set();
            const intensity = warpSettings?.intensity || 0;

            if (track.channels) {
                track.channels.beats.events.forEach(event => {
                    let step = event.step;
                    if (step < cropStart || step > cropEnd) return;
                    step = step - cropStart;
                    if (warps.size > 0) step = applySequenceWarp(step, cropEnd - cropStart, warps, intensity);
                    const time = stepToTime(step) + timeOffset;
                    if (time >= 0) playbackTimeouts.push(setTimeout(() => playDrumSound(event.drumIndex, false), time));
                });

                track.channels.harmony.forEach(channel => {
                    channel.notes.forEach(note => {
                        if (note.startStep > cropEnd || (note.endStep !== null && note.endStep < cropStart)) return;
                        const noteId = `${channel.channelIndex}-${note.startStep}-${Date.now()}`;
                        let startStep = Math.max(note.startStep, cropStart) - cropStart;
                        if (warps.size > 0) startStep = applySequenceWarp(startStep, cropEnd - cropStart, warps, intensity);
                        const startTime = stepToTime(startStep) + timeOffset;
                        if (startTime >= 0) {
                            playbackTimeouts.push(setTimeout(() => {
                                const sustainedNote = createSustainedNote(note.events[0].freq, note.events[0].filter, channel.sceneIndex);
                                activeSustainedNotes.set(noteId, sustainedNote);
                            }, startTime));
                        }
                        if (note.endStep !== null) {
                            let endStep = Math.min(note.endStep, cropEnd) - cropStart;
                            if (warps.size > 0) endStep = applySequenceWarp(endStep, cropEnd - cropStart, warps, intensity);
                            const endTime = stepToTime(endStep) + timeOffset;
                            if (endTime >= 0) {
                                playbackTimeouts.push(setTimeout(() => {
                                    const sustainedNote = activeSustainedNotes.get(noteId);
                                    if (sustainedNote) {
                                        sustainedNote.gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.05);
                                        setTimeout(() => { try { sustainedNote.oscillator.stop(); } catch(e) {} }, 150);
                                        activeSustainedNotes.delete(noteId);
                                    }
                                }, endTime));
                            }
                        }
                    });
                });
            }
        }

        document.getElementById('importBtn').addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.tracks) data.tracks.forEach(t => { t.name = t.name || file.name.replace('.json', ''); mixerTracks.push(t); });
                        else if (data.master?.clips) data.master.clips.forEach(c => { if (c.track) mixerTracks.push(c.track); });
                        else { data.name = data.name || file.name.replace('.json', ''); mixerTracks.push(data); }
                        renderTracks();
                        updateMasterPanelVisibility();
                    } catch (err) { console.error('Invalid JSON:', err); }
                };
                reader.readAsText(file);
            });
            fileInput.value = '';
        });

        document.getElementById('playAllBtn').addEventListener('click', () => { initAudio(); mixerTracks.forEach(track => playTrack(track)); });
        document.getElementById('stopAllBtn').addEventListener('click', stopAllPlayback);
        document.getElementById('clearAllBtn').addEventListener('click', () => { mixerTracks = []; renderTracks(); updateMasterPanelVisibility(); });

        function updateMasterPanelVisibility() {
            document.getElementById('masterPanel').classList.toggle('visible', currentScene === 3);
        }

        function addTrackToMaster(trackIndex) {
            const track = mixerTracks[trackIndex];
            if (!track) return;
            masterClips.push({
                trackIndex, name: track.name || `Track ${trackIndex + 1}`,
                cropStart: track.cropStart || 0, cropEnd: track.cropEnd || (track.totalSteps || TOTAL_STEPS),
                trackData: JSON.parse(JSON.stringify(track))
            });
            renderMasterTimeline();
        }

        function getClipDuration(clip) { return clip.cropEnd - clip.cropStart; }

        function renderMasterTimeline() {
            const inner = document.getElementById('masterTimelineInner');
            if (masterClips.length === 0) { inner.innerHTML = '<div class="master-empty">Drag tracks here or tap ‚ûï to add clips üéµ</div>'; return; }
            inner.innerHTML = '';
            masterClips.forEach((clip, index) => {
                const clipEl = document.createElement('div');
                clipEl.className = 'master-clip' + (index === selectedClipIndex ? ' selected' : '');
                clipEl.innerHTML = `
                    <div class="master-clip-name">${clip.name}</div>
                    <div class="master-clip-duration">${(stepToTime(getClipDuration(clip)) / 1000).toFixed(1)}s</div>
                    <button class="master-clip-remove" data-index="${index}">‚úï</button>
                `;
                clipEl.addEventListener('click', (e) => { if (!e.target.classList.contains('master-clip-remove')) { selectedClipIndex = index; renderMasterTimeline(); } });
                inner.appendChild(clipEl);
            });
            inner.querySelectorAll('.master-clip-remove').forEach(btn => btn.addEventListener('click', (e) => { e.stopPropagation(); masterClips.splice(parseInt(btn.dataset.index), 1); renderMasterTimeline(); }));
        }

        document.getElementById('masterPlayBtn').addEventListener('click', () => {
            initAudio(); stopAllPlayback();
            let timeOffset = 0;
            masterClips.forEach(clip => { playTrack(clip.trackData, timeOffset); timeOffset += stepToTime(getClipDuration(clip)); });
        });

        document.getElementById('masterDownloadBtn').addEventListener('click', () => {
            if (masterClips.length === 0) { alert('Add clips to master channel first!'); return; }
            const masterExport = {
                version: "3.0",
                license: { type: "CC0-1.0", name: "Creative Commons Zero v1.0 Universal", url: "https://creativecommons.org/publicdomain/zero/1.0/" },
                createdWith: "üåà Rainbow Unicorn Bunny Fluffcore üê∞",
                createdAt: new Date().toISOString(), bpm: BPM,
                master: { clips: masterClips.map(clip => ({ name: clip.name, cropStart: clip.cropStart, cropEnd: clip.cropEnd, track: clip.trackData })) },
                tracks: mixerTracks
            };
            downloadJson(JSON.stringify(masterExport, null, 2), 'fluffcore-master-cc0');
        });

        document.getElementById('masterClearBtn').addEventListener('click', () => { masterClips = []; selectedClipIndex = -1; renderMasterTimeline(); });

        // Remix Composer
        const remixFileInput = document.getElementById('remixFileInput');

        document.getElementById('remixImportBtn').addEventListener('click', () => remixFileInput.click());

        remixFileInput.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        const emptySlot = remixTracks.findIndex(t => t === null);
                        if (emptySlot === -1) { alert('All 4 slots are full!'); return; }
                        
                        let trackData = null;
                        if (data.master?.clips) trackData = { name: data.master.clips[0]?.name || file.name.replace('.json', ''), data: data };
                        else if (data.tracks) trackData = { name: file.name.replace('.json', ''), data: data };
                        else trackData = { name: data.name || file.name.replace('.json', ''), data: data };
                        
                        remixTracks[emptySlot] = trackData;
                        renderRemixSlots();
                    } catch (err) { console.error('Invalid JSON:', err); }
                };
                reader.readAsText(file);
            });
            remixFileInput.value = '';
        });

        function renderRemixSlots() {
            document.querySelectorAll('.remix-track-slot').forEach((slot, index) => {
                const track = remixTracks[index];
                if (track) {
                    slot.classList.add('filled');
                    slot.innerHTML = `<span class="remix-slot-name">${track.name}</span><span class="remix-slot-remove" data-slot="${index}">‚úï Remove</span>`;
                } else {
                    slot.classList.remove('filled');
                    slot.innerHTML = `<span class="remix-slot-label">Track ${index + 1}</span>`;
                }
            });
            document.querySelectorAll('.remix-slot-remove').forEach(btn => {
                btn.addEventListener('click', (e) => { e.stopPropagation(); remixTracks[parseInt(btn.dataset.slot)] = null; renderRemixSlots(); });
            });
        }

        // Warp checkboxes
        document.querySelectorAll('.warp-checkbox input').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const warpType = checkbox.dataset.warp;
                if (checkbox.checked) activeWarps.add(warpType);
                else activeWarps.delete(warpType);
                checkbox.parentElement.classList.toggle('active', checkbox.checked);
            });
        });

        document.getElementById('warpIntensity').addEventListener('input', (e) => {
            warpIntensity = parseInt(e.target.value);
            document.getElementById('intensityValue').textContent = warpIntensity + '%';
        });

        // License selection
        document.querySelectorAll('.license-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.license-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                selectedLicense = option.dataset.license;
                document.getElementById('copyrightHolder').classList.toggle('visible', selectedLicense === 'mit');
            });
        });

        document.getElementById('remixPlayBtn').addEventListener('click', () => {
            initAudio(); stopAllPlayback();
            let timeOffset = 0;
            remixTracks.forEach(trackSlot => {
                if (!trackSlot) return;
                const data = trackSlot.data;
                const warpSettings = { warps: activeWarps, intensity: warpIntensity };
                if (data.master?.clips) {
                    data.master.clips.forEach(clip => {
                        if (clip.track) { playTrack(clip.track, timeOffset, warpSettings); timeOffset += stepToTime((clip.cropEnd || TOTAL_STEPS) - (clip.cropStart || 0)); }
                    });
                } else if (data.tracks) {
                    data.tracks.forEach(track => { playTrack(track, timeOffset, warpSettings); timeOffset += stepToTime(track.totalSteps || TOTAL_STEPS); });
                } else { playTrack(data, timeOffset, warpSettings); timeOffset += stepToTime(data.totalSteps || TOTAL_STEPS); }
            });
        });

        document.getElementById('remixDownloadBtn').addEventListener('click', () => {
            const validTracks = remixTracks.filter(t => t !== null);
            if (validTracks.length === 0) { alert('Add at least one track to remix!'); return; }
            
            const composerName = document.getElementById('composerName').value || 'Anonymous';
            const remixTitle = document.getElementById('remixTitle').value || 'Untitled Remix';
            const copyrightHolder = document.getElementById('copyrightHolder').value || composerName;
            const year = new Date().getFullYear();

            let license;
            if (selectedLicense === 'cc0') {
                license = { type: "CC0-1.0", name: "Creative Commons Zero v1.0 Universal", url: "https://creativecommons.org/publicdomain/zero/1.0/", dedication: "To the extent possible under law, the creator has waived all copyright and related or neighboring rights to this work." };
            } else {
                license = {
                    type: "MIT",
                    name: "MIT License",
                    copyright: `Copyright (c) ${year} ${copyrightHolder}`,
                    text: `Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.`
                };
            }

            const remixExport = {
                version: "3.0",
                type: "remix",
                title: remixTitle,
                composer: composerName,
                license,
                createdWith: "üåà Rainbow Unicorn Bunny Fluffcore üê∞",
                createdAt: new Date().toISOString(),
                bpm: BPM,
                warpSettings: { activeWarps: Array.from(activeWarps), intensity: warpIntensity },
                sourceTracks: validTracks.map(t => ({ name: t.name, data: t.data }))
            };

            const prefix = selectedLicense === 'cc0' ? 'remix-cc0' : 'remix-mit';
            downloadJson(JSON.stringify(remixExport, null, 2), prefix);
        });

        document.getElementById('remixClearBtn').addEventListener('click', () => {
            remixTracks = [null, null, null, null];
            activeWarps.clear();
            warpIntensity = 50;
            document.getElementById('warpIntensity').value = 50;
            document.getElementById('intensityValue').textContent = '50%';
            document.querySelectorAll('.warp-checkbox input').forEach(cb => { cb.checked = false; cb.parentElement.classList.remove('active'); });
            document.getElementById('composerName').value = '';
            document.getElementById('remixTitle').value = '';
            document.getElementById('copyrightHolder').value = '';
            renderRemixSlots();
        });

        // Scene navigation
        const sceneContainer = document.getElementById('sceneContainer');
        const dots = document.querySelectorAll('.dot');

        function updateScene(index) {
            currentScene = Math.max(0, Math.min(4, index));
            sceneContainer.style.transform = `translateX(-${currentScene * 20}%)`;
            dots.forEach((dot, i) => dot.classList.toggle('active', i === currentScene));
            updateMasterPanelVisibility();
        }

        let swipeStartX = 0, isSwiping = false;
        document.querySelector('.app-container').addEventListener('touchstart', (e) => {
            if (e.target.closest('.touch-pad, .mode-btn, .drum-btn, .ctrl-btn, .mixer-container, .master-panel, .remix-container')) return;
            swipeStartX = e.touches[0].clientX; isSwiping = false;
        });
        document.querySelector('.app-container').addEventListener('touchmove', (e) => {
            if (e.target.closest('.touch-pad, .mode-btn, .drum-btn, .ctrl-btn, .mixer-container, .master-panel, .remix-container')) return;
            if (Math.abs(e.touches[0].clientX - swipeStartX) > 30) isSwiping = true;
        });
        document.querySelector('.app-container').addEventListener('touchend', (e) => {
            if (e.target.closest('.touch-pad, .mode-btn, .drum-btn, .ctrl-btn, .mixer-container, .master-panel, .remix-container')) return;
            if (isSwiping) {
                const deltaX = e.changedTouches[0].clientX - swipeStartX;
                if (deltaX > 50) updateScene(currentScene - 1);
                else if (deltaX < -50) updateScene(currentScene + 1);
            }
        });

        dots.forEach((dot, index) => dot.addEventListener('click', () => updateScene(index)));

        // Initialize
        updateScene(0);
        [0, 1, 2].forEach(i => updateActiveModeDisplay(i));
        renderTracks();
        renderMasterTimeline();
        renderRemixSlots();
    </script>
</body>
</html>
